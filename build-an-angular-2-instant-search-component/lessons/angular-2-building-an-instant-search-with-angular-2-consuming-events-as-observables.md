In this video, we will learn how to consume events from our template as observables to build a richer user experience. Our starting point is a simple instance search with Wikipedia. As I type into the text box, we immediately see the results.

Building this kind of thing, we'll face issues such as sending too many requests or getting a lot of auto-responses. We would like to solve these issues in a functional reactive way using **observables**.

Before we get started with that, let's a quick look at the counter-implementation. We created our Wikipedia search service to perform `Jsonp` request against the Wikipedia API. We injected the `Jsonp` service and created a `search` method that takes `string` as a parameter.

**Wikipedia-search.service.ts**
``` javascript
import { Injectable } from '@angular/core';
import { URLSerachParams, Jsonp } from '@angular/http';

@Injectable()
export class WikipediaSearchService {
  constructor(private jsonp: Jsonp) { }

  search (term: string) {
    let search = new URLSerachParams();
    search.set('action', 'opensearch');
    search.set('search', term);
    search.set('format', 'json');

    return this.jsonp.get('http://en.wikipedia.org/w/api.php?callback=JSONP_CALLBACK', {search})
               .map(response => response.json()[1]);
  }
}
```
We then call out to the Wikipedia API to make the request. We also `map` the results of that. Our observable only carries an area of strings containing the results of our API request.

Let's open up our `app.component.ts`. As we can see, it consumes the `WikipediaSearchService` via [dependency injection](https://egghead.io/courses/angular-2-dependency-injection-di-explained). It also exposes a method called `search` to be invoked from the template.

**app.component.ts**
``` javascript
import { Component } from '@angular/core';
import { WikipediaSearchService } from './wikipedia-search.service';

// application wide shared Rx operators
import 'rxjs/add/operator/map';

@Component({
  moduleId: module.id,
  selector: 'app-root',
  remplateUrl: 'app.component.html',
  styleUrls: ['app.component.css']
})
export class AppComponent {
  items:Array<string>;
  constructor(private service:WikipediaSearchService) {}

  search(term: string) {
    this.service.search(term)
                .subscribe(results => this.items = results);
  }
}
```
We also see that we are saving the `results`, our array, to an instance property called `items`. Since our service is using the `map` operator, we are importing it here for application-wide usage. Let's take a look at the template. It's a really basic markup, just enough to render an `input` box and the list.

**app.component.html**
``` html
<div> 
  <h2>
    <input (input)="seach($event.target.value)">
    <ul>
      <li *ngFor="let item of items">{{item}}</li>
    </ul>
  </h2>
</div>
```
We see that we listen for the input event on our `input` box. Whenever that happens, we invoke the `search` method that we created on our component. We have a simple unsorted list with list items generated by `ngFor` of our collection of items.

Now, that's all good. But in order to do things such as debouncing or deduplicating, we have to find a way to consume the changes of the input box as an observable of string. We can solve that using a `Subject` that we have to import from the rxjs library.

**app.component.ts**
``` javascript
import { Subject } from 'rxjs/Subject';
```
Notice that the build runs while I'm typing, which is why we sometimes see an error in the output. A `Subject` is an observable that we can subscribe to, but at the same time, we can also **emit notifications** on it. In a way, we can see it as a proxy between the actual event and an observable of that event.

We need to create a property of type subject of string. Let's call it `term$`. Some people use a dollar suffix to indicate that a variable is an observable. We use this convention here, too, but that's really just a convention that some people use, so feel absolutely free to ignore it.

Now that we have the `Subject`, we need to make sure to subscribe to emitted changes and invoke our `search` method from here. We can do that either in the constructor or in the `OnInit` hook. It would be a bit cleaner to do that in the `OnInit` hook, but for the purpose of this exercise, we can keep it here. 

**app.component.ts**
``` javascript
export class AppComponent {
  items:Array<string>;
  term$ = new Subject<string>();
  constructor(private service:WikipediaSearchService) {
    this.term$.subscribe(term => this.search(term))
  }

  search(term: string) {
    this.service.search(term)
                .subscribe(results => this.items = results);
  }
```
So far, there's no one actually raising notifications on our `Subject`. Let's change our template to not directly invoke `search`, but call `term$.next` instead.

**app.component.html**
``` javascript
<div> 
  <h2>
    <input (input)="term$.next($event.target.value)">
    <ul>
      <li *ngFor="let item of items">{{item}}</li>
    </ul>
  </h2>
</div>
```
By doing that, we are forwarding the input event into our subject, and that's it. Our `Subject` still works the same way as before, but we are now proxying the user input through an observable, which is exactly what we need to proceed with our next refactoring.
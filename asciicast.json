{"react-building-a-react-js-app-basic-routing-with-react-router":"Let's talk a little bit more about the importance of **components**. We talked about how to build a component in the last video, but we didn't really get too much into the **parent-child relationships** with components. You'll notice here that what I've done is I've highlighted every component in red. The deeper the red, that means the more **nested** the component is.\n\n![Red Components](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/redComponents.png)\n\nThe good thing about **React**, the nice thing about React is that you're able to have components which **manages the state**. Then you're able to **pass that state** down to your **child component**. What we have here is this container right here is one component. Then I'm taking **data** from that **component**, and I'm **passing** it down to these **children** components.\n\nSo that makes it really easy to reason about your data because now I know that my data, the state of my application, is mostly living in this component. If that data changes or that state changes, I know exactly where it changed at.\n\nWhat we're going to do first, just so we can see this idea, is we're going to build another component. Go ahead and go over to your `components` folder and make a new filed called `home.js`. The component we're going to build is this main component that you see here when you first load up the app, so this one right here.\n\n![Main Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/mainComponent.png)\n\nLet's go ahead and in `home` we're going to `require` React. Then we're going to make a variable called `home` and set it equal to `React.createClass` as we normally do. Here we're going to have a `render` method, which is going to return us what our **UI** looks like. What it's going to have is a class name of `text-center`. All it's going to say is, \"Search by GitHub username above.\"\n\n### Home.js\n```javascript\n\tvar React = require('react');\n\tvar Home = React.createClass({\n\t\trender: function(){\n\t\t\treturn (\n\t\t\t\t<h2 classname=\"text-center\">\n\t\t\t\t\tSearch by Github Username Above\n\t\t\t\t</h2>\n\t\t\t)\n\t\t}\n\t});\n```\n\n\nYou'll notice we use `className` here instead of `class`. Because `class` is a reserved word in JavaScript and technically we're in a JavaScript file, in order to do styling or in order to do classes with React, if it says classes, we need to use `className` instead of just `class`.\n\nNow that we've done that, if we head over to our page here you'll notice that we need some sort of way to have these components of order. You'll notice here I have this `menu` component here\n\n![Menu Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/menuComponent.png)\n\nand I have another component here,\n\n![Another Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/anotherComponent.png)\n\nbut when I go to this new `route` I want this component to stay here and I want to load in all these other components.\n\nYou'll also notice we've introduced this new idea of **route parameters**. What we're describing is this idea of a **routing**. What we're going to use is `react-router` for this. Because we're doing routing, we don't want our **main** controller to be in charge of **rendering** our component anymore, so what we're going to do is head over to `main.js` and remove `react.render` from there.\n\n### Main.js\n``` javascript\nReactDOM.render(<Main />, document.getElementById('app'));\n```\n\nInstead you're going to do `module.exports` main. Now whenever we `require` main we're going to get this component.\n\n### Main.js\n``` javascript\nmodule.exports = Main;\n```\n\nLast thing, because `main.js` is no longer going to be **handling** the rendering of our app, we can go ahead and delete this line.\n\n### Main.js\n``` javascript\nvar ReactDOM = require('react-dom');\n```\n\nNow what we're going to do is make another component that is basically in charge of handing our routing. Go ahead and, in your `app` file, create a new file called `app.js`.\n\n![App.js](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/appFile.png)\n\nThe very first thing, as always, is we are going to `require` React. Then, because `app.js` is going to be in charge of our rendering, we are going to `require react-dom` as we did earlier.\n\nNow let's go ahead and get our router in here by `requiring react-router`. **react-router** is going to return an **object**, obviously, and we want router to be a **property** on that object called `router`. Then the last thing we're going to require is this routes object we're going to make here in a little bit.\n\n### App.js\n``` javascript\nvar React = require('react');\nvar ReactDOM = require('react-dom');\nvar Router = require('react-router').Router;\nvar routes = require('./config/routes');\n```\n\nNow let's go ahead and head over to our terminal. Let's `npm install`, save it, react-router at version number 1.0.1. react-router has a dependency of the history package. Let's go ahead and install version 1.13.1 of that.\n\n![npm install](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/npmInstall.png)\n\nNow let's head over and finish up our `app.js` file. Just like we did before, we're going to call `ReactDOM.render`, but instead of passing in a **component** here what we're going to do is actually pass in our **router**, which makes sense because our router is going to be what's handling the **different routes** in our application.\n\n**Routes**, which we will eventually build, is basically just an **instruction sheet** to router to decide which component to render based on which route we're at, in very simple terms. The second property, the second argument to `.render` is going to be `getElementById` app.\n\n### App.js\n```javascript\n\tReactDOM.render(\n\t\t<Router>{routes}</Router>,\n\t\tdocument.getElementbyId('app')\n\t)\n```\n\nThis is looking good. We need to change one thing. If you'll remember, in our `webpack.config` file we had our **main entry point** being `component/Main.js`, but this is no longer the case. It's actually `App.js` now.\n\n### webpack.config.js\n```javascript\nentry: \"./app/App.js\",\n```\nOur `App.js` file looks good. Now we need to go ahead and build out our routes.\n\nLet's go ahead and make our `config` folder. We have our folder called config, and inside of that let's make a `route.js` file. As I mentioned earlier, this file is going to be the **instruction sheet** for our router so our router knows which React components to render based on which path we're at.\n\nWhat we're going to do is go ahead and require all of our components that we've built so far. We have `main`, and now let's go ahead and get our `home` component, and, of course, we're going to require our `router` with React router. Then that router has a route property under `Router.route`.\n\n### routes.js\n```javascript\n\tvar React = require('react');\n\tvar Main = require('../components/Main');\n\tvar Home = require('../components/Home');\n\tvar Router = require('react-router');\n\tvar Route = Router.Route;\n```\n\nWe've required everything we need. Let's go ahead and describe what we're going to export from this file. What I really like about `react-router` is your **routes** can be expressed as **JSX** just like you're used to. Here we're going to set a path.\n\nWhat's going to happen is whenever anybody goes to the **route path** in our application the component they're going to get **served** is this `main component`. You'll remember from earlier the main component, all it's going to do is render \"Hello world.\"\n\nTo recap again, all we're doing is we're **exporting** the instructions for our router which will then go to our `App.js` and our router now **receives** those routes and says, \"OK, whenever someone is at the **home index** of our app, go ahead and **render** this main component.\"\n\n### routes.js\n```javascript\n\tmodule.exports = {\n\t\t<Route path=\"/\" component={Main}>\n\n\t\t</Route>\n\t};\n```\n\nLet's go ahead and see if this works. Run `Webpack`. We get some errors. That's because this is components, not component. Let's run it again. We're good, so if we go and refresh this view, we get \"Hello world,\" but now this \"Hello world\" is being **served** to us by our **router**.\n\nYou'll notice earlier when we take a look at our application, we don't want just \"Hello world.\" We want something a little bit more complex. We want this idea of routing. We want to even be able to have a home route that we can hit and it gives us this component. Then when we switch over, that component gets swapped out with this new component.\n\nAlso, too, you'll notice that this menu bar we want to stay up here the whole time.\n\n![Menu Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/menuComponent.png)\n\nWe basically want this menu to always be an active route. Then it just renders some child components.\n\n![Child Components](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/bodyComponent.png)\n\nNow I'm back in my `route.js` file. We know what we want to do is we want to **specify** some **children** routes.\n\nThe very first thing I'm going to do is require index route from the router.\n\n### routes.js\n```javascript\nvar IndexRoute = Router.IndexRoute;\n```\n\nEventually what we're going to have is a bunch of stuff like this. When I get to users, the component we're going to use is this `user` component,\n\n### routes.js\n```javascript\n\tmodule.exports = {\n\t\t<Route path=\"/\" component={Main}>\n\t\t\t<Route path=\"users\" component={users}\n\t\t</Route>\n\t};\n```\n\nbut we don't have that now.\nWhat if we had a bunch of these but none of these matched the certain path that we're on?\n\n### routes.js\n```javascript\n\tmodule.exports = {\n\t\t<Route path=\"/\" component={Main}>\n\t\t\t<Route path=\"users\" component={users}\n\t\t\t<Route path=\"users\" component={users}\n\t\t\t<Route path=\"users\" component={users}\n\t\t\t<Route path=\"users\" component={users}\n\t\t</Route>\n\t};\n```\n\nWe need some sort of default path. That's where `IndexRoute` comes into play. `IndexRoute` says, \"Specify this component or **activate** this component if **none** of our other routes that we had earlier **match**.\"\n\n### routes.js\n```javascript\n\tmodule.exports = {\n\t\t<Route path=\"/\" component={Main}>\n\t\t\t<IndexRoute component={Home} />\n\t\t</Route>\n\t};\n```\n\nBecause we don't have any other **child routes**, every time we go to our main url this `home` component now is going to be **activated** and rendered. What we should see to the screen is `search by GitHub username`, but as we talked about earlier, we don't just want to render `search by GitHub username`. We also want to render the `header` in the menu bar.\n\nLet's head over to our `Main.js` file. Here I'm just going to paste in this code. You'll notice up here all we have is this `nav`, but down here we're rendering `this.props.children`. this.props.children is going to get replaced with whatever the **active** component is.\n\n### Main.js\n```javascript\n\tvar Main = React.createClass({\n\t  render: function(){\n\t    return (\n\t      <div className=\"main-container\">\n\t        <nav className=\"navbar navbar-default\" role=\"navigation\">\n\t          <div className=\"col-sm-7 col-sm-offset-2\" style={{marginTop: 15}}>\n\t            MENU\n\t          </div>\n\t        </nav>\n\t        <div className=\"container\">\n\t          {this.props.children}\n\t        </div>\n\t      </div>\n\t    )\n\t  }\n\t});\n```\n\nIf we go back to our routes file, when I go to `/path` we're going to render menu, which is going to come up and render this menu, but we're also going to render this `IndexRoute`, which is our `home` component. Then `this.props.children` is going to get swapped out with our `home` component, which will say, \"Search by GitHub username.\"\n\nLet's go ahead and see if this works. `Webpack` is still running. I'll hit refresh. There we go. We have our `menu` component because `main` is **active**. The `home` route is also **active**, so we get \"Search by GitHub username.\"\n","react-building-a-react-js-app-component-validation-with-proptypes":"One of the fundamental pieces of **React** is to be able to **build components** and to be able to have those components be **reusable** throughout your entire application. Part of making your components reusable is making sure that these **props** that we **pass** in the component have **prop type validation** on them. What I mean by that, is when we use `user` profile, our user profile component will be pretty worthless if we don't give it a `username`, and if we don't give it a `bio`. The same thing with `repos` and with `notes`.\n\nIf we come in here and we just render the `notes` component list this, \n\n### Profile.js\n``` javascript\nusername={this.props.params.username}\n```\nit's going to break because the `notes` component is very reliant upon this `username` and upon these `notes`. \n\n### Profile.js\n``` javascript\nnotes={this.state.notes}\n```\nWhat we can do, and a feature that React gives us is this idea of **propTypes**. If we head over to our `repos.js` file, what we can do is as a property on a **createClass** object, we can come in here and add **propTypes**.\n\n### Repos.js\n``` javascript\nvar Repos = React.createClass({\n\tpropTypes: {\n\n\t},\n```\n\nBasically what this is going to allow us to do, is it's going to allow us to **validate** the props that are being **passed** in to make sure that they're the **right type**, and also if we want them to be **required**, we can also specify that as well. So looking at how the `repos` component is being used, you'll notice here we're passing in `username` and we're passing in a `repo`. So what we're going to do is on `propTypes` we're going to say the `username` is `react.propTypes`. It's going to be a string, and we want that to be `required`.\n\nThen with repos again `React.propTypes`, this is now going to be an array, and it's going to be `required`. \n\n### Repos.js\n``` javascript\npropTypes: {\n\tusername: React.PropTypes.string.isRequired,\n\trepos: React.PropTypes.array.isRequired\n},\n```\n\nWe don't have to have it required, but as we talked about earlier when we use repos, we basically need a `username` and a `repos` array for this, so let's go ahead and now when we render our `repos` component, let's go ahead and take out `username` and let's see what happens. \n\n### Profile.js\n``` javascript\t\n<Repos repos={this.state.repos}/> \n```\n\nNow you'll notice we get this warning, \"Failed **propType** required `username` was not specified in `repos`.\"\n\nBecause we said this `username` needs to be required, it threw an error. So we come back here and instead of throwing in a string, let's go ahead and throw in an array, and remember we said it needs to be a string, and it needs to be required. \n\n### Profile.js\n``` javascript\n<Repos username={[]} repos={this.state.repos}/> \n```\n\nSo what's going to happen is this is going to throw another error, and say, hey, you gave us an **array** and we actually needed a **string**. So again this whole idea of **propTypes** or type **checking** makes it so that our **components** are being **used** in the way that we **intend** for them to be used.\n\nLet's go ahead and go over to `userProfile`, and let's add some prop checking here. So again, check out `propTypes` which is an object and we want the user name to be `react.propTypes.string`, it is `required`, and then `bio` is same thing, `react.propTypes` it's going to be an object that is **required** for this component to **function correctly**.\n\n### UserProfile.js\n``` javascript\nvar UserProfile = React.createClass({\n\tpropTypes: {\n\t\tusername: React.PropTypes.string.isRequired,\n\t\tbio: React.PropTypes.object.isRequired\n\t},\n```\n\nThen let's go ahead and head over to `notes`, and again `notes` we're going to set up `propTypes` and the `username` that we're passing in as always is a string that is required, this component also needs `notes` that is an array that is required. \n\n### Notes.js\n``` javascript\nvar Notes = React.createClass({\n\tpropTypes: {\n\t\tusername: React.PropTypes.string.isRequired,\n\t\tnotes: React.PropTypes.array.isRequired\n\t}\n```\n\nAll right, so let's go ahead and run this and make sure everything's working well. **Perfect.** Let's test this one more time, let's go to our `notes`, let's go ahead and take off notes and this should throw an error.\n\nThere we go, `failed propType`. So everything is working correctly, but now what we've done is we've made the `userProfile`, the `repos`, and the `notes` component all **validate** that they're being **used correctly**.","react-building-a-react-js-app-componentwillreceiveprops-and-react-router":"One thing you may have noticed as you were playing around with this is, every time we go to a new **route**, we're **refreshing** the **whole view**. If I go to another user, it refreshes the view. That's obviously not what we want, because we're building a **single-page** application and we don't want the **whole view to refresh**.\n\nThat's because we have a typo or a bug in one of our previous videos. Go ahead and go to the `searchGitHub` component. Right here, instead of being a `profile/`, we want it to be `/profile/`, and then the `username`. Once we do that, then we should get something like this. I'm going to go home, I'll type in a new `username`, and there we go.\n\n### SearchGithub.js\n``` javascript\nhandleSubmit: function() {\n  var username = this.usernameRef.value;\n  this.usernameRef.value = '';\n  this.history.pushState(null, \"/profile/\" + username);\n}\n```\n\nYou'll notice here, if I type in a new `username` now, it doesn't **refresh** the **whole** view. This **data** is still the **same**, even though we're going to a new **route**. The reason for that is because we're receiving new **props** into our **components**, but we're not doing anything with those **props**. React gives us another handy little **lifecycle method** that we could hook into, which is called `componentWillReceiveProps`.\n\nWhat this does is, whenever our `Profile` component receives new **props**, this callback function is going to get invoked. What's nice is, whenever react-router changes routes, because our **routing** is going through **props**, this function will get invoked, and then we'll have those new **props**.\n\nLet's go ahead and see this. What I'm going to do is, inside of `componentWillReceiveProps`, let's just `console.log`. The next Props are with the `nextProps`.\n\n### Profile.js\n``` javascript\ncomponentWillReceiveProps: function(nextProps){\n  console.log('The next props are', nextProps);\n}\n```\n\nWhat we should see here is, if I refresh this and go to a new `username`, we get these new **props** and, under **params**, we have the **username**.\n\n![nextProps](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/nextProps.png)\n\nLet's go ahead and change up our component a little bit. What I'm going to do is let's go ahead and make an `init` function. What's going to happen is we're going to **call** this data or this chunk of code when the **component mounts**, but also we want to **set up** a **listener** to the new user whenever we **receive new props**.\n\nLet's go ahead and I'm going to copy this code and put it into my `init` function.\n\n### Profile.js\n```javascript\ninit: function(){\n  var childRef = this.ref.child(this.props.params.username);\n  this.bindAsArray(childRef, 'notes');\n\n  helpers.getGithubInfo(this.props.params.username)\n    .then(function(data){\n      this.setState({\n        bio: data.bio,\n        repo: data.repos\n      })\n    }.bind(this))\n},\n```\n\nThen, in `componentDidMount`, I'm gong to call `this.init`.\n\n### Profile.js\n```javascript\ncomponentDidMount: function(){\n  this.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n  this.init();\n}\n```\n\nWe don't want to query `this.props.params.username`, because what's going to happen is, when this `init` function runs, if we call it in `componentWillRecieveProps`, we're not giving it the new **props**.\n\nIf I'm on my own profile, `TylerMcGinnis`, if we type in a new user, `this.props.params.username` is still going to be `TylerMcGinnis`. What we want to do is let's go ahead and have this `init` function take in a `username`, and then we'll switch out all of these for that `username`.\n\n### Profile.js\n```javascript\ninit: function(username){\n  var childRef = this.ref.child(username);\n  this.bindAsArray(childRef, 'notes');\n\n  helpers.getGithubInfo(username)\n    .then(function(data){\n      this.setState({\n        bio: data.bio,\n        repo: data.repos\n      })\n    }.bind(this))\n},\n```\n\nThen what we can do is, whenever the component **receives props**, we're going to go ahead and **pass** `this.init(nextProps.params.username)`.\n\n### Profile.js\n``` javascript\ncomponentWillReceiveProps: function(nextProps){\n  this.init(nextProps.params.username);\n}\n```\n\nAlso, when our **component mounts**, we're still going to **pass** it `this.props.params.username`.\n\n### Profile.js\n```javascript\ncomponentDidMount: function(){\n  this.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n  this.init(this.props.params.username);\n}\n```\n\n`Init` is now taking in the `username`, whether it's from the **params** itself or, when we receive new props, those next props coming in.\n\nLet's go ahead and see if this works. Everything looks good. Webpack is running. Hit refresh. Let's go to Spencer's profile. `This.state.notes` is already **bound** to a Firebase reference.\n\nThe reason this is being thrown is because, in our `componentDidMounts`, we run `init`, and that comes in here and **binds** to our `notes` property on our **state**. Firebase isn't going to let us **bind** to **multiple** things, which make sense.\n\nWhat we're going to do is, inside of `componentWillReceivesProps`, before we call `init` again, let's go ahead and call `this.unbind` notes.\n\n### Profile.js\n``` javascript\ncomponentWillReceiveProps: function(nextProps){\n  this.unbind('notes');\n  this.init(nextProps.params.username);\n}\n```\n\nNow when we receive **props**, we're going to **unbind** what we bound to in our component when it **mounted**, and then we're going to **rebind** to the new `username`.\n\nLet's see if this works now. `TylerMcGinnis`, there we go. Our data loads, and we can go to any `username` we want here.\n","react-building-a-react-js-app-es6-refactor-createclass-to-javascript-classes-and-proptypes":"Let's go ahead and start **refactoring** some of our **components**. In this video, we are going to refactor all of the components in our `notes` folder, so let's go ahead and start with `NotesList`.\n\nThe very first thing, instead of **require**, we need to `import react` from `react`. Once we've done that, now what we need to do is you'll notice here we're using `react.createClass`. Instead, let's go ahead and use the **built-in ES6 class** syntax.\n\nWe're going to go `class`, and the name of our class. We're going to have it `extend react.Component`, and let's go ahead and capitalize Component. Now we've created our class, and real quick, let's go ahead and `export default NotesList`.\n\nWhat we're going to do now is have our `render` method. Remember, we don't need to type out function. Then I'm just going to copy this and throw it into here. The next thing we're going to do is let's go ahead and **remove function** and use our **arrow syntax**, as we talked about before.\n\n### NotesList.js\n```javascript\nimport React from 'react';\n\nclass NotesList extends React.Component{\n  render(){\n    var notes = this.props.notes.map((note, index) => {\n      return <li className=\"list-group-item\" key={index}>{note['.value']}</li>\n    })\n\n    return (\n      <ul className=\"list-group\">\n        {notes}\n      </ul>\n    )\n  }\n}\n\nexport default NotesList;\n```\n\nThroughout this series, what we've done to **loop over** any lists is we've **mapped outside** of our **return block** here and then saved it into a **variable**, and then used our variable down here. I want to show you a little bit different syntax, just because you might see it.\n\nI'm going to go ahead and take this **map function** and I'm going to throw it in right there, and then just fix this indention. This is technically the same thing as before, but instead of saving it to a variable, we're now actually just **looping inside** of our **template**.\n\nEven take this a little bit further, so what I'm going to do is I'm going to **destructure** `this.props`. What that means is I can do something like this.\n\nWhat that's done is it's taken the `notes` property on `this.props`, which is this guy right here, and **saved** it into a **variable** called `notes`. I can get rid of this line right here, so `notes.map`, and now what I can do -- and I could have done this before, but I'm just showing you now -- is I'm going to go ahead and use the **implicit return** here to keep this all on one line like that. Then we get something like this.\n\n### NotesList.js\n```javascript\nrender(){\n  { notes } = this.props;\n  return (\n    <ul className=\"list-group\">\n      {notes.map((note, index) => <li className=\"list-group-item\" key={index}>{node['.value']}</li>)}\n    </ul>\n  )\n}\n}\n```\n\nI'm not a huge fan of that, just because it seems a little bit scrunched just to force it to be on one line, but you've seen how powerful **arrow syntax** can be, and you've also seen this new idea of **destructuring variables**.\n\nLet's see and make sure this still works. `NotesList` is still going fine, so cool. There is our `NotesList` component.\n\nThe last change I'm going to make is, if you'll notice, this is how we had it before. If you use curly braces, then you need to have an explicit return here.\n\n### NotesList.js\n```javascript\nrender(){\n  { notes } = this.props;\n  return (\n    <ul className=\"list-group\">\n      {notes.map((note, index) => {\n          return <li className=\"list-group-item\" key={index}>{node['.value']}</li>)\n        }\n      }\n    </ul>\n  )\n}\n}\n```\n\nBut what some people do -- I'm just doing this so you can see all the different patterns -- is if you put a `paren` right here and not a `curly brace`, you can still...let's move this down here, and then we need two of these. Those match up, and then these should match up.\n\nYou can still take advantage of that **implicit return**, as long as you don't have a `curly brace` here. Some people really like this syntax. I'm not a huge fan of it, but it should still work, as well. Let's see.\n\n### NotesList.js\n```javascript\nrender(){\n  const { notes } = this.props;\n  return (\n    <ul className=\"list-group\">\n      {notes.map((note, index) => (\n          <li className=\"list-group-item\" key={index}>{node['.value']}</li>\n        ))}\n    </ul>\n  )\n}\n}\n```\n\nThere's our `notes` component still rendering. I'm going to keep it like this, but you've seen the different patterns that people use for looping over items in a **react** component.\n\nLet's head over to our `AddNote` component, so same thing. Instead of that, we're going to `import react` from `react`. We're going to create a class called `AddNote`, which `extends React.Component`, export default, `AddNote`.\n\nLet's go ahead and move our render method up, so here, we type **render**, which returns this **UI**. Add a `handleSubmit` method. Notice here, we don't have to put commas in between our methods because we're technically not in an object, so I'm going to move this up, as well.\n\n### AddNote.js\n```javascript\nimport React from 'react';\n\nclass AddNote extends React.Component {\n  handleSubmit(){\n    var newNote = this.note.value;\n    this.note.value = '';\n    this.props.addNote(newNote);\n  }\n\n  render(){\n    return(\n      <div className=\"input-group\">\n        <input type=\"text\" className=\"form-control\" placeholder=\"Add New Note\" ref={this.setRef}/>\n        <span className='input-group-btn'>\n          <button className=\"btn btn-default\" type=\"button\" onClick={this.handleSubmit}>Submit</button>\n        </span>\n      </div>\n    )\n  }\n}\n\nexport default AddNote\n```\n\nOne tricky thing that we need to do is when you're using `React.createClass`, that this keyword is automatically **auto-bound** to the **correct context** for you, which makes it really convenient. But one got-you you're going to have over and over again with ES6 classes in **react** is that `this` keyword is **not** auto-bound.\n\nWe want `this` keyword **inside** of this function to be the same as `this` keyword, so what we're going to do is just a `handlesubmit.bind`, so that this keyword **inside** of this **context** is the **correct** one. That looks good, so now the only thing left we need to do is worry about `propType`.\n\n### AddNote.js\n```javascript\nrender(){\n  return(\n    <div className=\"input-group\">\n      <input type=\"text\" className=\"form-control\" placeholder=\"Add New Note\" ref={this.setRef}/>\n      <span className='input-group-btn'>\n        <button className=\"btn btn-default\" type=\"button\" onClick={this.handleSubmit.bind(this)}>Submit</button>\n      </span>\n    </div>\n  )\n}\n```\n\nWhat's a little bit different about **prop types**, too, is you have to **add** them to the **class itself**, so we're going to come up here and type `AddNote`, and as a **property** on `AddNote`, have our `propTypes` object, and that should be it for this component.\n\n### AddNote.js\n```javascript\nclass AddNote extends React.Component {...}\n\nAddNote.propTypes = {\n  username: React.PropTypes.string.isRequired,\n  addNote: React.PropTypes.func.isRequired\n}\n\nexport default AddNote\n```\n\nOne small fix real quick is to set this **equal** to the **object** instead of having a **colon**, so set this to equals. Now we just need to do a few more things.\n\nFirst, let's go ahead and fix our `setRef` function, and delete all this junk down here. Get rid of the `function` keywords. We have `setRef` now.\n\n### AddNote.js\n```javascript\nsetRef(ref){\n  this.note = ref;\n}\n```\n\nWhat we could do is we could come in here and do `.bind(this)` again, because remember that `this` keyword is going to be different. But **another pattern** that I really like is instead of doing `.bind`, what we can do is we can create a **arrow function** right here and then call `this.setRef`. Then we're going to get a ref, and then let's pass that there.\n\n### AddNote.js\n```javascript\nrender(){\n  return(\n    <div className=\"input-group\">\n      <input type=\"text\" className=\"form-control\" placeholder=\"Add New Note\" ref={(ref) => this.setRef(ref)}/>\n      <span className='input-group-btn'>\n        <button className=\"btn btn-default\" type=\"button\" onClick={() => this.handleSubmit()}>Submit</button>\n      </span>\n    </div>\n  )\n}\n```\n\nRemember, **arrow** functions **don't create** their own **context**. `this` keyword inside this arrow function is the **exact same** as the one **out here**, so this is actually the preferred way that I like to get around the **auto-binding** issue. Instead of using `.bind`, I just like to create these **arrow functions**. Then we'll invoke `handleSubmit`, and then this function will run.\n\nThis looks good. Let's go ahead and check webpack. Let's start webpack, and it looks like we have an issue. That's back in `NotesList`, so come here.\n\nYou can't **destructure** like this. You obviously need to **assign** it a **variable type**, so we have `const`. That looks good.\n\nWhat we need to do is every time we change a component, we need to go and figure out where that **component is being required** and **change** that, as well. Let's go ahead, and everywhere we're using `AddNote`, which is right here, so we're going to `import AddNote` from `AddNote`, and then we also change `NotesList`.\n\n### Notes.js\n```javascript\nvar React = require('react');\nimport NotesList from './NotesList';\nimport AddNote from './AddNote';\n```\n\nLet's go ahead and do that one, as well, and then let's check these files. I think we're good. Let's see if webpack's good. Let's see if we have any errors. So far, so good.\n\nLet's go ahead and modify the last file, our `Notes.js` file. I swapped out our **require** for some **imports**. Now let's go ahead and create a `class Notes` which extends `React.Component`, and then we're going to `export default Notes`.\n\n### Notes.js\n```javascript\nimport React from require('react');\nimport NotesList from './NotesList';\nimport AddNote from './AddNote';\n\nclass Notes extends React.Component {\n  render(){\n    return(\n      <div>\n        <h3> Notes for {this.props.username} </h3>\n        <AddNote username={this.props.username} addNote={this.props.addNote} />\n        <NotesList notes={this.props.notes} />\n      </div>\n    )\n  }\n}\n\nexport default Notes;\n```\n\nLet's go ahead and move our render method up, so that looks good. Now the only thing left to do is our `propTypes`.\n\n### Notes.js\n```javascript\nNotes.propTypes = {\n  username: React.PropTypes.string.isRequired,\n  notes: React.PropTypes.array.isRequired,\n  addNote: React.PropTypes.func.isRequired\n}\n```\n\nAgain, the very last thing is now we need to figure out where we're importing `Notes`, or where we're requiring it, and modify that. Let's go ahead and change in our `Profile.js` component to our file, `import Notes` from `Notes`, from this. There we go.\n\n### Profile.js\n```javascript\nvar React = require('react');\nvar Router = require('react-router');\nvar Repos = require('./Github/Repos');\nvar UserProfile= require('./Github/UserProfile');\nimport Notes from './Notes/Notes';\nvar ReactFireMixin = require('reactfire');\nvar Firebase = require('firebase');\nimport getGithubInfo from '../utils/helpers';\n```\n","react-building-a-react-js-app-es6-refactor-non-components":"Now we have our very nice notetaker GitHub application where we can search for a username. We get that user's information. Then we can go ahead and add a new note about this user.\n\nAs you might have noticed, as we've been developing this, we haven't really been utilizing any of the new features from **ECMAScript 2015**, or as I'll refer to it in the next few videos, **ES6**.\n\nWhat we're going to do now is we're going to go through this entire application and we are going to rewrite a lot of our code with these brand new features coming in from ES6.\n\nThe first question you might have is, \"Hey, I need some way to transpile my ECMAScript 6 code to **ES5** code,\" because right now not all browsers support **ES6**.\n\nWell, remember the very first or second video of this series when we set up our presets? What we did is we said, \"Hey, we want to be able to **transpile** React code, but we also want to be able to transpile ES2015 or ES6 code. So we can do this now without really making any changes to our `webpack-config` file.\n\nFirst, let's start with our files that aren't **React** components, and then we'll go from there. The very first thing, we don't need to do this `require` syntax anymore, because ES6 comes with its own built-in **import/export module system**. What we can do is we are going to `import` Axios from Axios. Line two is the exact same thing as line one, so we can go ahead and get rid of line one.\n\n### helpers.js\n``` javascript\nimport axios from 'axios'\n```\n\nActually one of my favorite features of ES6 is called **string literals**. Notice here how we have one `string` plus a `variable` plus another `string`. If we go ahead and we change these to instead of being **single quotes**, we change them to a **back tick**, and if you don't know where a back tick is, that's fine, because I didn't know when I first looked at it either. A back tick is right left to the one key on just a normal QWERTY keyboard.\n\nWhat we can do now is, I'm going to go ahead and remove these. We can **remove** our `plus signs` as well. Since this `username` is a variable, all we do is `dollar sign`, curly brace, and then close the curly brace. It's almost like we have our own **templating language** now, where this evaluate to the string that we had before.\n\n### helpers.js\n``` javascript\nfunction getRepos(username){\n  return axios.get(`https://api.github.com/users/${username}/repos`);\n}\n```\n\nWe're going to come down here and do the same thing here. Get rid of these single quotes. Instead of adding, we're just going to use our **string literal**. There we go.\n\n### helpers.js\n``` javascript\nfunction getUserInfo(username){\n  return axios.get(`https://api.github.com/users/${username}`);\n}\n```\n\nThe next thing we're going to do is we can go ahead and remove this function, just like that. With methods, instead of writing the name of the function, or the name of the method, colon, and then function, what you can do is you can **remove function** completely. This is just shorthand for that. That's really nice. It will save us some keystrokes.\n\nI'm going to move this down just for now so we can still see it. What we can do here is this idea of **arrow functions** in JavaScript. Now, the benefit of an arrow function is it doesn't create a **new context**, so that the `this` keyword, **outside** of the arrow function, will be the **exact same** as the one **inside** the arrow function. But because we're not using the `this` keyword in this code at all, it won't give us too much benefit, except we don't have to write the word `function`, again, just saving us some keystrokes.\n\nIt's going to take in an array. All right, so there's that. One other thing that I see real quick is, again, we don't need to do **moduled exports** because **ES6** comes with its own **module system**. Since we're only exporting one thing, we can type `export default helpers`, and these are roughly the same thing.\n\n### helpers.js\n``` javascript\nvar helpers = {\n  getGithubInfo(username){\n    return axios.all([getRepos(username), getUserInfo(username)])\n      .then((arr) => {\n        return {\n          repos: arr[0].data,\n          bio: arr[1].data\n        }\n      })\n  }\n}\n\nexport default helpers;\n```\n\nNow, in our other file, we can `import helpers`, and we'll get it just as normal.\n\nI see two more small changes we can make here. With ES6 we get **two** more ways to **declare** a **variable** with let and with const. They both do two different things, but I'm going to use, and I try to use, **const** for most of my variables, if I can.\n\nThe **const** declaration creates a **read-only reference** to a value. Basically what this means is that `helpers`, it's **not** necessarily **immutable**, in a sense where you can still **reassign properties** to `helpers`, but you **can't reassign** the variable **itself**. It gets you one step closer to immutability, kind of, which is a little bit nicer.\n\n### helpers.js\n``` javascript\nconst helpers = {\n  getGithubInfo(username){\n    return axios.all([getRepos(username), getUserInfo(username)])\n      .then((arr) => {\n        return {\n          repos: arr[0].data,\n          bio: arr[1].data\n        }\n      })\n  }\n}\n```\n\nIt's usually a **good practice** to have all of your variables be **const** if they can. If they can't, then switch to **let**. If they can't be let, then go to **var**.\n\nThe next thing I see here is with this arrow function. With **arrow functions**, you can make it so you **don't** have to **explicitly return** the value you're returning if you do it all on **one** line. What I mean by that is...I'm going to get rid of this return. We're just going to return this object. I'm going to delete this guy. I'm going to bring this all onto one line, and then delete that first one.\n\nHere, notice how we're just **returning** an object? Because we're returning an object, I'm going to put an opening paren here, a closing paren right here. Now what's happening is, because we don't have an opening curly brace right here, this arrow function's just going to say, \"Hey, looks like they want to return this object.\"\n\n### helpers.js\n``` javascript\nconst helpers = {\n  getGithubInfo(username){\n    return axios.all([getRepos(username), getUserInfo(username)])\n      .then((arr) => ({repos: arr[0].data, bio: arr[1].data}))\n  }\n}\n```\n\nWhat we've done is we've taken all those three or four lines of code and made it into one line with **implicitly returning** this object. It just makes things a little bit cleaner.\n\nNow you'll notice we're just exporting an object which has one property on it, or one method on it, `getGitHubInfo`. What we might as well do, instead of **creating** an object, just to `export` a property on that object, what if we just exported this **function**, this `getGitHubInfo` function, as the main default thing that's being exported from our helpers' module? Let me go ahead and reformat this.\n\n### helpers.js\n``` javascript\nexport default function getGithubInfo(username){\n  return axios.all([getRepos(username), getUserInfo(username)])\n    .then((arr) => ({repos: arr[0].data, bio: arr[1].data}))\n}\n```\n\nNow what's going to happen is because we're exporting default, if we import `getGitHubInfo`, what we can do, say we're in another file, I would just do import `getGitHubInfo` from this path to `helpers`, whatever. OK?\n\nThis is where things get a little bit tricky if you're still using the older `require` syntax, because what's going to happen is if we change this, and we say `getGitHubInfo` equals `require`, and then the path to `helpers`, then all the sudden `getGitHubInfo` going to be an **object** with a **default property** that then has a `getGitHubInfo` property on that.\n\nBecause we've made this change, we need to go and find where we're also requiring this file, and make those necessary changes. Let's head over to our `profile` view. You'll notice here we are requiring `helpers`. Let's go ahead and just change this to `import`. I believe it was `getGitHubInfo` from, and then the same path, `utils/helpers`. That allows us to get rid of this Require statement.\n\n### Profile.js\n``` javascript\nimport getGithubInfo from '../utils/helpers'\n```\n\nAll right, so that looks good. That looks good. Let's go ahead and make sure this is still working. Webpack is running. Helpers is not defined. There we go. We changed the `import`, but we didn't actually change `invocation`.\n\n### Profile.js\n``` javascript\ninit: function(username){\n  var childRef = this.ref.child(username);\n  this.bindAsArray(childRef, 'notes');\n\n  getGithubInfo(username)\n    .then(function(data){\n      this.setState({\n        bio: data.bio,\n        repos: data.repos\n      })\n    }.bind(this))\n}\n```\n\nNow, if we hit refresh, hopefully what we should see is everything's back to normal. Now let's head over to our `app.js` file and make some changes here.\n\nAs usual, we're going to have the new **import module** system going on here. I'm also going to change this one, as well. We're going to `import routes` from `.config/routes`. I need to go ahead and get rid of this equal sign.\n\n### App.js\n``` javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nvar Router = require('react-router').Router;\nimport routes from './config/routes';\n```\n\nYou'll notice here that we're not just **requiring** a module, but we're **requiring the module**, and then we're getting a **property** on that module. What we can do is this new ES6 syntax called named `imports`. What it allows us to do is it looks the same as other imports, but we've **wrapped** our import in this **object**, or in these curly braces. What that's doing is it's saying, \"OK. Go ahead and get React router, but **get** me the **router property** on this module, rather than the **whole module**.\" These two lines are essentially the same thing.\n\n### App.js\n``` javascript\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Router } = from 'react-router';\nimport routes from './config/routes';\n```\n\nLet's go ahead and see if Webpack is still working. There it goes. We're still good here. All right. Now let's jump over to our config routes file and do the same thing here, as well. We're going to do import from.\n\nThen, notice here, too, we have another opportunity to do **named imports** because, instead of `Router`, we actually want `Route` and we want `IndexRoute`. That looks good. The very last thing is we're going to export default that.\n\n### routes.js\n``` javascript\nimport React from 'react';\nimport Main from '../components/Main';\nimport Home from '../components/Home';\nimport Profile from '../components/Profile';\nimport { Route, IndexRoute} from 'react-router';\n\nexport default (\n  <Route path=\"/\" component={Main}>\n    <Route path=\"profile/:username\" component={Profile} />\n    <IndexRoute component={Home} />\n  </Route>\n);\n```\n\nLet's refresh this page. There we go, no errors. Webpack is still running.","react-building-a-react-js-app-es6-refactor-proptypes-in-es6":"This video is going to be very similar to the last video. Let's go ahead and **refactor** our `Repos.js` file, and our `UserProfile.js` file, in order to use more **ES6-type** syntax. First thing as always, we are going to `import React from react`, and delete this line.\n\nLet's go ahead and create our `UserProfiles` **class**, which `extends React.Component`. Once we do that, let's go ahead and `export default UserProfiles`. Once we've done that, let's go ahead and add our `render` method in here, which is going to return this **UI**.\n\n### UserProfile.js\n```javascript\nimport React from 'react'\n\nclass UserProfile extends React.Component {\n  render(){\n    return (\n      <div>\n        {this.props.bio.avatar_url && <li className=\"list-group-item\"> <img src={this.props.bio.avatar_url} className=\"img-rounded img-responsive\"/></li>}\n        {this.props.bio.name && <li className=\"list-group-item\">Name: {this.props.bio.name}</li>}\n        {this.props.bio.login && <li className=\"list-group-item\">Username: {this.props.bio.login}</li>}\n        {this.props.bio.email && <li className=\"list-group-item\">Email: {this.props.bio.email}</li>}\n        {this.props.bio.location && <li className=\"list-group-item\">Location: {this.props.bio.location}</li>}\n        {this.props.bio.company && <li className=\"list-group-item\">Company: {this.props.bio.company}</li>}\n        {this.props.bio.followers && <li className=\"list-group-item\">Followers: {this.props.bio.followers}</li>}\n        {this.props.bio.following && <li className=\"list-group-item\">Following: {this.props.bio.following}</li>}\n        {this.props.bio.following && <li className=\"list-group-item\">Public Repos: {this.props.bio.public_repos}</li>}\n        {this.props.bio.blog && <li className=\"list-group-item\">Blog: <a href={this.props.bio.blog}> {this.props.bio.blog}</a></li>}\n      </div>\n    )\n  }\n}\n\nexport default UserProfile;\n```\n\nLastly, we'll need to go and add `propTypes` onto our **class**. `UserProfiles.propTypes` equals that **Object**. This looks good. Let's go ahead and modify `Repos` now. We are going to `import React from react`, create our `Repos` class, which `extends React component`.\n\n### UserProfile.js\n```javascript\nUserProfile.propTypes = {\n  username: React.PropTypes.string.isRequired,\n  bio: React.PropTypes.object.isRequired\n}\n```\n\nLet's go ahead and throw our `render` method in here as well. Beautiful, and next, let's go ahead and add our profile, or add our `propTypes` to our `Repos` class. Now, let's go ahead, and let's move our **mapping** function inside of our components.\n\n### Repos.js\n```javascript\nimport React from 'react';\n\nclass Repos extends React.Component{\n  render(){\n    return (\n      <div>\n        <h3> User Repos </h3>\n        <ul className=\"list-group\">\n          {this.props.repos.map((repo, index) => {\n            return (\n              <li className=\"list-group-item\" key={index}>\n                {repo.html_url && <h4><a href={repo.html_url}>{repo.name}</a></h4>}\n                {repo.description && <p>{repo.description}</p>}\n              </li>\n            )\n          })}\n        </ul>\n      </div>\n    )\n  }\n}\n\nRepos.propTypes = {\n  username: React.PropTypes.string.isRequired,\n  repos: React.PropTypes.array.isRequired\n}\n\nexport default Repos\n```\n\nGoing to drop this right here, and indent this, change that to be an **arrow** function. Works great, so, now let's go ahead, and find where all of these are being **imported**, or these two files are being imported.\n\nI believe, it's just in our `Profile.js`. Here, we are going to `import Repos`, from `./Github/repos`, and then, we'll also `import UserProfile from ./Github/UserProfile`. Let's see if this's working. There we go.\n\n### Profile.js\n```javascript\nvar React = require('react');\nvar Router = require('react-router');\nimport Repos from './Github/Repos';\nimport UserProfile from './Github/UserProfile';\nimport Notes from './Notes/Notes';\nvar ReactFireMixin = require('reactfire');\nvar Firebase = require('firebase');\nimport getGithubInfo from '../utils/helpers';\n```\n","react-building-a-react-js-app-es6-refactor-routing-without-mixins":"We only have four more components left until our **entire** app has been **ES6-ified**, so what we're going to do real quick is take care of this `Home` component since it's really small.\n\n`import React from react`, and then let's go ahead and create a class `Home` which `extends React.Component`, so just the same stuff we've been doing. Have a `render` method which returns this object, and then let's go ahead and `export default Home`, so nothing new yet.\n\n### Home.js\n```javascript\nimport React from 'react';\n\nclass Home extends React.Component {\n  render(){\n    return(\n      <h2 className=\"text-center\">\n        Search By Github Username Above\n      </h2>\n    )\n  }\n}\n\nexport default Home;\n```\n\nNow let's head over to the `Main.js` file. Now, like usual, let's `import React from react`. Now let's create our `Main class`, which `extends React.Component`, and then we're going to `export default Main`. Once we do that, let's add our `render` method, which is going to return us the **UI** for this component.\n\n### Main.js\n``` javascript\nimport React from 'react';\nimport SearchGithub from './SearchGithub'\n\nclass Main extends React.Component {\n  render(){\n    return (\n      <div className=\"main-container\">\n        <nav className=\"navbar navbar-default\" role=\"navigation\">\n          <div className=\"col-sm-7 col-sm-offset-2\" style={{marginTop: 15}}>\n            <SearchGithub history={this.props.history}/>\n          </div>\n        </nav>\n        <div className=\"container\">\n          {this.props.children}\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default Main\n```\n\nThe last component we're going to modify in this video is the `SearchGitHub` component, so same thing. We're going to do this. You should be very used to this by now. We're going to create a class of `SearchGitHub`, which `extends React.Component`, and then we're going to `export default SearchGitHub`.\n\n### SearchGithub.js\n```javascript\nimport React from 'react';\nimport Router from 'react-router';\n\nclass SearchGithub extends React.Component {\n\n}\n\nexport default SearchGithub;\n```\n\nLet's bring these three functions up here. Let's get rid of the function, and let's get rid of these commas.\n\n### SearchGithub.js\n```javascript\nclass SearchGithub extends React.Component {\n  getRef(ref){\n    this.usernameRef = ref;\n  }\n  handleSubmit(){\n    const username = this.usernameRef.value;\n    this.usernameRef.value = '';\n    this.history.pushState(null, \"/profile/\" + username)\n  }\n  render(){\n    return (\n      <div className=\"col-sm-12\">\n        <form onSubmit={() => this.handleSubmit()}>\n          <div className=\"form-group col-sm-7\">\n            <input type=\"text\" className=\"form-control\" ref={(ref) => this.getRef(ref)} />\n          </div>\n          <div className=\"form-group col-sm-5\">\n            <button type=\"submit\" className=\"btn btn-block btn-primary\">SearchGitHub</button>\n          </div>\n        </form>\n      </div>\n    )\n  }\n}\n```\n\nIf you'll remember, **functions** inside of **classes** with **React** don't get **auto-bounded**, or `this` keyword doesn't get **auto-bound**. What we're going to have to do is make these **arrow** functions, which then **invoke** the **specific** function on the instance, and with `gitRef`, we're going to pass it ref.\n\nThis looks really good. Let's change this to `const` really quick. **Perfect**.\n\nNow what you'll notice is everything is good except for this guy right here. If you remember correctly, what the `Router.History` **mixin** is doing is it's taking our **instance** and it's **mixing** a few **methods onto it**. One of those methods is `history`, so we can call this `.history.pushSate`.\n\nBecause we **no longer** have that **mixin**, this `.history`'s going to be **undefined**. We need to find another way to get **history** into this `SearchGitHub` component.\n\nIf you check out our `routes`, what **React Router** does is if you have a **component** that's being **handled** by the `Router`, that component will **receive certain properties** and certain **methods** from the `Router`. The problem is `SearchGitHub` isn't being **handled** by the `Router`.\n\nBut we know that `Main` is, and `Main` is rendering `SearchGitHub`, so what if we do this? What if we say **history** is going to be `this.props.History` because **React Router** is going to pass `Main` a `history` method.\n\n### Main.js\n```javascript\nclass Main extends React.Component {\n  render(){\n    return (\n      <div className=\"main-container\">\n        <nav className=\"navbar navbar-default\" role=\"navigation\">\n          <div className=\"col-sm-7 col-sm-offset-2\" style={{marginTop: 15}}>\n            <SearchGithub history={this.props.history}/>\n          </div>\n        </nav>\n        <div className=\"container\">\n          {this.props.children}\n        </div>\n      </div>\n    )\n  }\n}\n```\n\nThen what we can do is in `SearchGitHub`, let's add some `propTypes` of `history`, which is going to be `React.propTypes.Object`, and it's going to be **required**.\n\n### SearchGithub.js\n```javascript\nSearchGithub.PropTypes = {\n  history: React.PropTypes.object.isRequired\n}\n```\n\nThen all we need to do is change this `.history` to `this.props.pushState`, so let's see if this works, and it does.\n\n### SearchGithub.js\n```javascript\nhandleSubmit(){\n  const username = this.usernameRef.value;\n  this.usernameRef.value = '';\n  this.props.history.pushState(null, \"/profile/\" + username)\n}\n```\n\nTo recap, because we can't use **mixins** with **React**, we have to figure out another way to get `history` into this **component**. We do that by **passing** `history` from the `Main` component into `SearchGitHub` as **props**, and the reason that the `Main` component has access to `this.props.history` is because the `Main` component is being controlled by the **Router**.\n","react-building-a-react-js-app-making-server-requests-in-react-with-axios":"Our app is coming together very nicely, but one thing we need to do now is we need to go and **fetch the data** from **github** in order to **populate** both of these components. What we're going to use is this tool called **Axios**. Axios allows us to make **http requests** or network requests in its problem space, so it's really nice. If you're coming from an **Angular** background it's very similar to **$HTTP** in Angular. Head over to your terminal and go ahead and run `npm install axios`.\n\nNow once that is done, let's go ahead and we're going to make a helper file for us that is going to handle our network request. So let's go ahead and make a new folder called `utils`, inside this `utils` folder go ahead and make a file called `helpers.js`. In this file we're going to go ahead and `require Axios`,\n\n### helpers.js\n``` javascript\nvar axios = require('axios');\n```\n\nand we're really concerned about two things, we're concerned about **getting** the **users repos**, and getting **their profile**.\n\nSo let's go ahead and make two functions, the first one let's called `getRepos`, it takes in a `username` and it's going to return whatever `axios.get` returns us, and we're going to hit this **endpoint** and get that user's repos.\n\n### helpers.js\n``` javascript\nfunction getRepos(username){\n  return axios.get('https://api.github.com/users/' + username + '/repos');\n};\n```\n\nSo if you're not familiar with promises, don't worry about it too much right now, we'll talk a little bit more about promises here in a little bit. For now, let's just create another function called `getUserInfo` that takes in a username and it's going to return us whatever `axios.get` returns us, and we're going to append `username`.\n\n### helpers.js\n``` javascript\nfunction getuserinfo(username){\n  return axios.get('https://api.github.com/users/' + username);\n};\n```\n\nIn a nutshell this is how promises work. If I were to invoke the `getRepos` function, let's say I pass in my github username, that's going to return us this **promise** object, OK? This promise object then has a `.then` property on it, and the function that we pass to `.then`, the **callback** function, is going to get invoked whenever this **promise** gets **resolved**.\n\n### helpers.js\n``` javascript\nvar promisObj = getRepos('tylermcginnis');\npromisObj.then(function(data){\n  console.log(data);\n});\n```\n\nSo basically the way this will work is we call `getRepos`, that returns us a promise that says, \"OK, when we go and we **fetch the data** from this **API**, when that data is back, go ahead and **invoke this callback** function and then `console.log(data)`.\" So it's really convenient, it kind of gets around the idea of having callbacks and callback hell and all that stuff. But the way we're going to use this is actually a little bit more advanced.\n\nWe're going to **create** an **object** that we're going to **export**, and a property on this object is going to be called `getGitHubInfo`, because if you think about what we're doing, we basically need both of these **functions** to be **invoked** at the **same time**, and when we get the data back from both of them, when we have the `repos` and when we also have the user information, we then need to **render** the component and show all that **data** to the **view**.\n\nWhat we're going to do is we're going to use a feature of Axios called `axios.all`. Let's make sure we passed in our `username` here first. All right, so what `axios.all` does is it takes in an array of promises, so let's invoke `getRepos`, and let's also invoke `getUserInfo`.\n\n### helpers.js\n``` javascript\nvar helpers = {\n  getGitHubInfo: function(username){\n    return axios.all([getRepos(username), getuserinfo(username)])\n    .then(function(arr){\n\n    });\n  }\n};\n```\n\nSo then what we can do is that will **return** us a **promise** which we pass a callback function to, and now what's going to happen is instead of just waiting for one promise to be resolved and then this function will be invoked, what happens is `axios` will wait for both of these **promises** to be **resolved**, and then it will pass us an **array of data** we got back from both of these invocations.\n\nSo it's really convenient because we can **make** these **requests** the **exact same time**, and when both of them are ready, this function will run passing us that array. So let's go ahead from here all we want to do is **return an object** that has a `repos` property and it returns us an array, the very first property in this array is going to be the repository, the **users repositories** because that's the first item in the array that we passed axios, and the second property in this object is going to be **bio** and it's going to be at the first index.\n\n### helpers.js\n``` javaScript\n.then(function(arr){\n  return {\n    repos: arr[0].data,\n    bio: arr[1].data\n  }\n});\n```\n\nSo again, to recap what's going to happen here is when we invoke `getGitHubInfo` we pass it a `username`, we then will invoke `axios.all` and pass it two **promises**. When both of these promises **resolve**, or when this data has gotten back from github, both of these pieces of data, this function's going to run and it's then going to **pass** us back an **object** with our `repos` and with our `bio`.\n\nSo now let's go ahead and head over to our `profile` view or profile component and let's utilize this. So let's go ahead first and we're going to require helpers, and I believe we need to go back a folder and then into utils, and then to helpers,\n\n### Profile.js\n``` javaScript\nvar helpers = require('../utils/helpers.js');\n```\n\nand then let's go ahead and make it so when this **component mounts**, after it sets up the Firebase stuff, let's go ahead and **invoke** `helpers.getGitHubInfo`.\n\nWe're going to pass it the `username` from the **route params** and that will return us a **promise** which we then can pass a function which will get **invoked** when our **data** object is **ready** or when our github data is ready. Once it's ready we can call `this.setstate` and we set the `bio` to the bio object and we set the `repos` property to the repos object.\n\n### Profile.js\n``` javaScript\ncomponentDidMount: function(){\n  this.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n  var childRef = this.ref.child(this.props.params.username);\n  this.bindAsArray(childRef, 'notes');\n\n  helpers.getGitHubInfo(this.props.params.username)\n    .then(function(data){\n      this.setState({\n        bio: data.bio,\n        repos: data.repos\n      })\n    }.bind(this))\n},\n```\n\nAll right, so there's one little gotcha in here, if you're familiar with the `this` keyword in JavaScript you already know that `this` keyword is different than `this` keyword, and that sounds a little bit weird, but basically whenever you go **inside** of a **new function** a **new context** is created, and so `this` keyword is going to be a little bit **different** than `this` keyword.\n\nSo what we need to do as our goal is to basically make it so `this` keyword is the **same** as `this` keyword because if it's not, then this one isn't going to have a `setState` property. So one trick you can do is here, you can use `.bindThis` and in a nutshell what `.bind` does, it **returns** you a new **function** and you're allowed to **specify the context** of that new function, so all this is doing is it's saying, \"Hey, return me a new function with a context, or with the `this` keyword inside of that function referring to this keyword instead of `this` keyword inside of that.\"\n\nThat sounds confusing, I know, but if that's still confusing go ahead and look up how the `this` keyword works and you will be entertained for days. One note really quick about the this keyword, if you're still confused I've made three lessons and they're actually my favorite Egghead lessons I think I've made on the `this` keyword. So if you're still confused go ahead and check out this playlist, and it should help you out a little bit.\n\nAll right, so if this worked correctly what's going to happen is when the component mounts it does some Firebase stuff, it goes and gets our github information, gets the data resets the state and changes our bio and our repos property. We can clear these out now too, and then as of React .14 we can no longer just get `JSON` and show it to the view so what we're going to do is instead of just spitting that all in the view, let's go ahead and just `console.log(this.props.repos)` so we can see what that is.\n\nMake sure everything's working, and then same thing in our `userProfile` component let's go ahead and remove `bio` and instead just `console.log('BIO: ',this.props.bio)`. All right, webpack is running, let's see if this works. So we should see here is **two responses**, we also have `propType`, that's fine for now. So `bio.data`, we have all our data and then `repos.data` here are all our repositories.\n\n![Finished](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/09-finished.png)\n\nSo now one more thing, let's go ahead and make it so we don't get the whole response object, but we just get the data. So inside of our `helpers` instead of returning just the **first item**, let's go ahead and return the **first item with data** then `.data` here as well. So that should give us just this data properties Check it out, and there we go, there's our `bio` and there are our `repos`.\n","react-building-a-react-js-app-managing-state-in-child-components":"We've talked a lot in this series how the **state** of these three components is being **managed** in this **outer profiles** component. \n\n![Main Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/components.png)\n\nWhat we're going to talk about in this video is how we can **manipulate the state** of an **outer component** from **inside** of **another** component. Specifically, this `addNote` component is what we're going to build.\n\nLet's go ahead and head over to our `Profile.js` file. The biggest thing to remember is that you want to **manipulate** the state where that state **lives**. For example, this **state** of this `notes` is living in the `profiles` component, so what we want to do is we want a write a function inside of this `profiles` component, **pass** that function **down** to our **child** component, and then eventually invoke it.\n\nLet's go ahead and write that very first function that we're going to pass down to our child component. We're going to call it `handleAddNote`. What it's going to do is it's going take in a new note, and then we are going to update Firebase with the new note.\n\n### Profile.js\n``` javascript\nhandleAddNote: function(newNote){\n\t// update firebase, with the newNote \n},\n```\nWhat's going to happen is, because we have **bound** our **note's state** to our `childRef` here, whenever we update this **endpoint**, those changes are automatically going to be **pushed through to our state**. \n\n### Profile.js\n``` javascript\nvar childRef = this.ref.child(this.props.params.username);\nthis.bindAsArray(childRef, 'notes'); \n```\n\nWhat's going to happen is we'll update Firebase. Those changes will be pushed through. The component will re-render, and then we'll have that brand new note.\n\nHere, what we're going to do is we're going to say `this.ref.child` at `this.props.params.username`, because we **don't** want to **update** our **root ref**. Instead, we want to update the endpoint at our root `ref/`, whatever the username we're on is. Then we're going to go one level deeper. I'm going to say `.child(this.state.notes.length)`.\n\n### Profile.js\n``` javascript\nhandleAddNote: function(newNote){\n\t// update firebase, with the newNote \n\tthis.ref.child(this.pops.params.username).child(this.state.notes.length)\n},\n```\n\nWhat's going to happen is we're eventually going to call `.set()`. What `.set()` does is, whatever we **pass in**, that's going to **replace the data** at this **location**. Or, if there's no data there, as in this case, it's going to **set that new data**.\n\nThere's a few ways to do this. Firebase also has a `.push()` method that we can use, but that's going to create its own `key`. Instead, we want to use the the key `012345`, or however many items are in the array. What I'm going to do now is we're going to pass in `newNote`.\n\nAgain, what's going to happen here is when this function's called, it's going to be given a new note, \n\n### Profile.js\n``` javascript\nthis.ref.child(this.pops.params.username).child(this.state.notes.length).set(newNote),\n```\n\nand then we're going to go to `this.ref.child/TylerMcGinnis`, or `/whatever` username we're on. Then we're going to go to `/` however many items are in the array, and then we're going to set a brand-new item there to `newNotes`.\n\nWhat that should do is that should just **append** this `newNote` to the end of our **Firebase**. What that will do is, because we have, up here, used `bindAsArray`, that's going to receive new data, and that's gong to **push** through to our note **state**, which then **updates the view**.\n\nNow what we need is we need some way to get this `handleAddNote` down to our `notes` container so that we can create that button and invoke it there. As you guessed it, what we're going to do is **pass** it in as a **prop**. Let's say `addNote`, and it's going to be equal to `this.handle.addNote`.\n\n### Profile.js\n``` javascript\n<Notes\n\tusername={this.props.params.username}\n\tnotes={this.state.notes}\n\taddNote={this.handleAddNote} /> \n```\n\nNow let's head over to our `notes` component. Very first thing, let's go ahead and add a `propType`, because this is going to be `required`. For functions, you do you func, end is required.\n\n### Notes.js\n``` javascript\nproptypes: {\n\tusername: React.PropTypes.string.isRequired,\n\tnotes: React.PropTypes.array.isRequired,\n\taddNote: React.PropTypes.func.isRequired,\n}\n```\n\nAs we talked about with the `NotesList`, we could go ahead and make this component a part of the `notes` component, or what we can do is just make it its own component, which I like a little bit better.\n\nLet's go ahead and create a new file in our `notes` folder, and let's call it `addNote.js`. We're going to `require` react. We're going to create our component, using `react.createClass`. Then, as always, we're going to `export` it.\n\nHere, let's go ahead and very first thing now we're going to do some type checking. It's going to take in a `username` which is a string, and it is `required`. It's also going to take in that `addNote` function that we're getting from our `profile` component. So, `PropTypes.func.isRequired`.\n\n### AddNote.js\n``` javascript\nvar React = require('react');\n\nvar AddNote = React.createClass({\n\tpropTypes: {\n\t\tusername: React.PropTypes.string.isRequired,\n\t\taddNote: React.PropTypes.func.isRequired,\n\t}\n});\n\nmodule.exports = AddNote; \n```\n\nNow let's go ahead and have a render function. What this is going to return is our **UI**, which a `div`. Let's give it a classname of `input-group`. Now what we want to do is we need an input field, and we also need a button that we can click to submit the new note.\n\nLet's go and make our input field, `type=text`, classname is `form-control`, which is a Bootstrap thing. Let's also give it a placeholder of `addNewNote`.\n\n### AddNote.js\n``` javascript\nvar React = require('react');\n\nvar AddNote = React.createClass({\n\tpropTypes: {\n\t\tusername: React.PropTypes.string.isRequired,\n\t\taddNote: React.PropTypes.func.isRequired,\n\t}\n\trender: function(){\n\t\treturn (\n\t\t\t<div className=\"input-group\">\n\t\t\t\t<input type=\"text\" className=\"form-control\" placeHolder=\"Add New Note\" />\n\t\t\t</div> \n\t\t)\n\t}\n});\n\nmodule.exports = AddNote; \n```\n\nNow what we want to do is, if you'll remember, we have our `handleAddNote` function. We eventually want to give that a new note. That **new note** is going to be whatever we **type** into this **input field**. What we need is a way to get the value of this input field before we pass it to our `addNote` function.\n\nWhat we're going to do is we're going to use this thing called a **ref**. \n\n### AddNote.js\n``` javascript\n<input type=\"text\" className=\"form-control\" placeHolder=\"Add New Note\" ref={}/>\n```\n\nWhat a **ref** is is basically like a **name tag** that you give an input field, so that you can access that **specific value later**. The **ref** I'm going to give it, we're going to give it a function. Let's call that function note `setRef()`.\n\n```javascript\nref={this.setRef}\n```\n\nInside of this function, we are going to be passed the specific **ref**, and then we're going to take that **ref**, and then **add** it as a **property** on our **instance**. Later, we'll be able to query this **property**, and we'll be able to get the value of this specific **input field**.\n\n### AddNote.js\n``` javascript\nvar React = require('react');\n\nvar AddNote = React.createClass({\n\tpropTypes: {\n\t\tusername: React.PropTypes.string.isRequired,\n\t\taddNote: React.PropTypes.func.isRequired,\n\t},\n\tsetRef: function(ref){\n\t\tthis.note = ref; \n\t},\n\trender: function(){\n\t\treturn (\n\t\t\t<div className=\"input-group\">\n\t\t\t\t<input type=\"text\" className=\"form-control\" placeHolder=\"Add New Note\" />\n\t\t\t</div> \n\t\t)\n\t}\n});\n\nmodule.exports = AddNote; \n```\n\nLet's go ahead and make a button. One side note -- this app isn't very accessible. I'm big into accessibility, but for the sake of just learning React, we're going to ignore this for now, which is something you should never do. This button is going to have a type of `button`, and we are going to have an `onClick` handler.\n\nNow what's going to happen is we want to run a certain function whenever someone clicks on this button. The function we're going to run, let's do `handleSubmit`. \nThen, up here, let's go ahead and make a `handleSubmit` method that doesn't do anything for now, until we finish off our button. Let's give it `Submit`, and then we'll close our button.\n\n### AddNote.js\n``` javascript\n\t<div className=\"input-group\">\n\t\t<input type=\"text\" className=\"form-control\" placeHolder=\"Add New Note\" />\n\t\t<span className='input-group-btn'> \n\t\t\t<button className=\"btn btn-default\" type=\"button\" onClick={this.handleSubmit}>Submit </button>\n\t\t</span>\n\t</div> \n```\n\nNow what we want to have happen is, whenever someone clicks on this button, we're going to grab the `value` from this input field and we're going to pass it to a function that we're eventually going to **pass down** as a **prop**.\n\nNow what we want to do is finish off this `handleSubmit` function. The very first thing that we need to do is we need to go to our `input form`, and then we need to grab the `value` off of it and save that. I'm going to save `var newNote = this.not.value`. Remember, `this.note` is coming because that is what we did here with `setRef`, with our ref. Then, `.value` is a **property** on our specific **ref**.\n\nSo we have the value, and then what I'm going to do is say `this.note.value` equals an **empty string**, just to clear that input field. Then I'm going to call `this.props.addNote`, **passing** it our **new note**. Remember, `addNote`, we're getting from our `Profile` component, so when we call `this.props.addNote`, we're going to that new note, **pass** it to handle `addNote`, which should then **update Firebase**.\n\n### AddNote.js\n``` javascript\t\nhandleSubmit: function(){\n\tvar newNote = this.note.value;\n\tthis.note.value = '';\n\tthis.props.addNote(newNote)\n},\n```\n\nNow we need to make sure that `addNote` is getting **passed** from our `Profile` component, all the way down to our `addNote` component. Let's go ahead and check out our `notes` component. Now let's go ahead and required `addNote`. \n\n### Notes.js \n``` javascript\nvar AddNote = require('./AddNote'); \n```\n\nNow what we can do is, right here, let's go ahead and throw that in.\n\n`AddNote` took in two things. It took in a `username`, which, again, we're getting from **props**, so `this.props.username`. It's going to also take in a `addNote` function, which we're also getting from **props**. If this is working correctly, the way it works is we have our `notes` component, and we're passing it the notes.\n\nWe're also passing it this `handleAddNote` function, which is right here, which is going to eventually, when it gets invoked, take in a new note, and then **set** -- whatever profile we're on -- a **new value** to whatever new note's passed in.\n\nIf we follow this, we go to `notes`. This creates a `addNotes` component, where we give it a `username` and we give it `addNote`.\n\n### Notes.js \n``` javascript\t\nrender: function(){\n\treturn (\n\t\t<div>\n\t\t\t<h3> Notes for {this.props.username} </h3>\n\t\t\t<AddNote username={this.props.username} addNote={this.props.addNote} />\n\t\t\t<NotesList notes={this.props.notes} />\n\t\t</div>\n  \t)\n}\n```\n\nIn `addNote`, when this button is **clicked**, whatever's in this **input field** gets **taken**, gets **reset**, and gets **passed** to the functions. Inevitably, something is wrong with this. Let's go ahead and see if it's working.\n\nSo Webpack is working, we refresh, and there we go. It worked","react-building-a-react-js-app-rendering-a-ui-of-dynamic-data":"This video we are going to build out the **UI** for our `user` profile component as well as our `repos` component. Since inside this `repos` component, what we're going to do is we're going to **map** over all of our repositories and basically make an **array of list items**. So here we're going to have a `repos` variable and we're going to **map** over our `repos`, the first parameter that the callback function the map takes is the **item** itself, or in this case the repository, then the second one is the **index**.\n\n### Repos.js\n``` JavaScript\nrender: function() {\n  var repos = this.props.repos.map(function(repo, index){\n    return()\n  })\n  return(\n    <div> REPOS<br />\n      Username: {this.props.username} <br />\n      REPOS: {this.props.repos} </div>\n  )\n}\n```\n\nSo here let's go ahead and return a list item and let's add some bootstrap-y stuff to it, so it's going to be a `list-group-item` and the key is going to be index. Whenever you're mapping over anything, **React** needs these **keys**. If you don't have these keys on every item in the array, then React is going to **throw an error**. This is kind of low-level React stuff, but it's how React optimizes when you remove or take something out of a list.\n\n### Repos.js\n``` JavaScript\nrender: function() {\n  var repos = this.props.repos.map(function(repo, index){\n    return(\n      <li className=\"list-group-item\" key={index}>\n      </li>\n    );\n  });\n  return(\n    <div> REPOS<br />\n      Username: {this.props.username} <br />\n      REPOS: {this.props.repos} </div>\n  )\n}\n```\n\nWhat we're going to do now is we are going to say if the `repo` has a `html_url` property, then let's go ahead and render an `H4` with a link to it, and the **link** is going to take us to this **URL**, the name is going to be `repo.name`, and then we're going to close `H4`. So what we're doing here is because not every repository has a `HTML`, or has a URL associated with it, so this is just making sure it has URL before it renders this. This is kind of a tricky way to do an `if statement` in JavaScript.\n\n### Repos.js\n``` JavaScript\nrender: function() {\n  var repos = this.props.repos.map(function(repo, index){\n    return(\n      <li className=\"list-group-item\" key={index}>\n        {repo.html_url && <h4><a href={repo.html_url}>{repo.name}</h4>}\n        {repo.description && <p>{repo.description}</p>}\n      </li>\n    );\n  });\n  return(\n    <div> REPOS<br />\n      Username: {this.props.username} <br />\n      REPOS: {this.props.repos} </div>\n  )\n}\n```\n\nThen next one is going to be very similar, so if this specific repository has a **description**, then what we're going to do is **render that description** inside of a paragraph tag and then close the paragraph. We have our `repos` array that's full of these list items now, and so now what we want to do is let's go ahead and change this around to where we have a header, that's the `User Repos`, and then underneath that let's go ahead and have our unordered list with a class name of `listgroup`. In here we're going to throw `repos`.\n\n### Repos.js\n``` JavaScript\nrender: function() {\n  var repos = this.props.repos.map(function(repo, index){\n    return(\n      <li className=\"list-group-item\" key={index}>\n        {repo.html_url && <h4><a href={repo.html_url}>{repo.name}</h4>}\n        {repo.description && <p>{repo.description}</p>}\n      </li>\n    );\n  });\n  return(\n    <div>\n      <h3> User Repos </h3>\n      <ul className=\"list-group\">\n        {repos}\n      </ul>\n    </div>\n  )\n}\n```\n\nIf this worked, then let's go ahead and start webpack.\n\n### Terminal\n``` Bash\nnpm start\n```\n\n![finished Repos](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/10-repoComponent.png)\n\nSo now our user repos is formatted a little bit better, we can click on these links and it'll take us to the github project. Now let's go ahead and fix the bio real quick. If we head over to our `userProfile.js` file, we're going to do roughly the same thing. This one's a little bit longer so I'm just going to paste it in. Not every repository is mandated to have all of these properties on it.\n\n### UserProfile.js\n``` JavaScript\nrender: function(){\n    return (\n      <div>\n        {this.props.bio.avatar_url && <li className=\"list-group-item\"> <img src={this.props.bio.avatar_url} className=\"img-rounded img-responsive\"/></li>}\n        {this.props.bio.name && <li className=\"list-group-item\">Name: {this.props.bio.name}</li>}\n        {this.props.bio.login && <li className=\"list-group-item\">Username: {this.props.bio.login}</li>}\n        {this.props.bio.email && <li className=\"list-group-item\">Email: {this.props.bio.email}</li>}\n        {this.props.bio.location && <li className=\"list-group-item\">Location: {this.props.bio.location}</li>}\n        {this.props.bio.company && <li className=\"list-group-item\">Company: {this.props.bio.company}</li>}\n        {this.props.bio.followers && <li className=\"list-group-item\">Followers: {this.props.bio.followers}</li>}\n        {this.props.bio.following && <li className=\"list-group-item\">Following: {this.props.bio.following}</li>}\n        {this.props.bio.following && <li className=\"list-group-item\">Public Repos: {this.props.bio.public_repos}</li>}\n        {this.props.bio.blog && <li className=\"list-group-item\">Blog: <a href={this.props.bio.blog}> {this.props.bio.blog}</a></li>}\n      </div>\n    )\n  }\n```\n\nBasically we're going to say if this specific...or not every `bio`, excuse me. We're going to say **if** this specific `userProfile` has an **avatar URL**, then go ahead and **load** their image. Or, if they have a company go ahead and load their company. But for example, not everyone has a blog associated with their profile, so we wouldn't want to just render an empty href if the blog property is actually undefined, that would not be useful.\n\nThese are all just checking to make sure those properties are truthy, if they are, it will go ahead and render those to the screen. Let's save that, webpack is good, let's check this and there we go.\n\n![Finish User Profile](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/10-finish.png)\n","react-building-a-react-js-app-state-props-and-thinking-in-react":"As we talked about a few videos ago, the biggest component in our application is going to be this `profile` component we'll make, because that's what's going to **manage the state** for this `userProfile` component, the `repos` component right here, and also the `notes` component. Let's go ahead in this video, let's make this `profile` component, and then let's just make these three child components.\n\n![App Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/AppComponent.png)\n\nLet's go ahead and head over to our `components` folder. Let's make a new file called `profile.js`. Very first thing we're going to do, as always, is `require React`. We're going to need `react-router` later on, so let's just require it right now. That should be good for now.\n\n### Profile.js\n``` javascript\nvar React = require('react');\nvar Router = require('react-router');\n```\n\nLet's go ahead and make a new profile variable and set it equal to `React.createclass` to create our component. Then, let's go ahead and set the `render` method. This render method is going to return. Let's go ahead and make sure that we `export` this component.\n\n### Profile.js\n``` javascript\nvar Profile = React.createclass({\n  render: function(){\n    return(\n      <div className=\"row\">\n        <div className=\"col-md-4\">\n        User Profile Component\n        </div>\n        <div className=\"col-md-4\">\n          Repos Component\n        </div>\n        <div className=\"col-md-4\">\n          Notes Component\n        </div>\n      </div>\n    )\n  }\n})\n\nmodule.exports = Profile;\n```\n\nLooking back at our application that's finished, you'll notice that this is the component we're building right now, the `profile` component. This component is going to be **managing** three different **states** really. It's going to be managing the user's profile data, the user's repo data, and this notes data.\n\nLet's come in our component. We're going to add a `getInitialState` method on this component. What `getInitialState` does is it's going to **set** the **initial** state of the component, meaning anything that this component is going to handle, any state that this component is going to handle, you're going to basically **initialize** that state right now.\n\nYou usually just initialize it with **empty data**. We're going to return `notes`, which is going to be an array, `bio`, which is going to be an object, and `repos`, which is going to be another array.\n\n### Profile.js\n``` javascript\ngetInitialState: function(){\n  return {\n    notes: [],\n    bio: {},\n    repos: []\n  }\n}\n```\n\nEventually, these are going to get **populated**. These data sets are going to be passed down to these children components, which they'll then **render**.\n\n\nLet's go ahead and add this new `profile` component to our routes. Now let's head over to `routes.js`. The very first thing we're going to do is require our new profile component that we made, `../component/Profile`.\n\n### routes.js\n``` javascript\nvar Main = require('../components/Main');\nvar Home = require('../components/Home');\nvar Profile = require('../components/Profile');\nvar Router = require('react-router');\nvar Route = Router.Route;\nvar IndexRoute = Route = Router.IndexRoute;\n```\n\nNow what we want to do is we want to be able to hook up our `profile` component to our `router`.\n\nDown here, we're going to say `route`. We're going to specify a new route. So whenever someone goes to our `app/profile/` some username, this route is going to be `active`. The component that's going to be **activated** is this `profile` component.\n\n### routes.js\n``` javascript\nmodule.exports = (\n  <Route path=\"/\" component={Main}>\n    <Route path=\"profile/:username\" component={Profile} />\n    <IndexRoute component={Home} />\n  </Route>\n);\n```\n\nLet's go ahead and verify that this is all hooked up now. When we go to our app/profile/any name, what we should see is our profile component, which should give us just this static text. `Webpack` is still running. If we hit refresh and then go to `/profile/tylermcginnis`, here we go. We got our static text.\n\n![Profile Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/ProfileComponent.png)\n\nYou might have seen this little gross hash up here. You can get rid of that. I'm not going to worry about it in this video, but if you want to get rid of it, go ahead and look into React router's create hash history.\n\nThe reason I'm not going to do it in this video is because you have to have a server. We're obviously serving these just going to the path itself. So we're not going to do it. But you can get rid of these using React router. Don't worry too much about those.\n\nEverything seems to be working, but what we still haven't done is we still haven't figured out a way to get the **username** that we pass in through the **URL** into our `profile` container. A very fundamental principle of React is this idea of **passing props** down to a component.\n\nYou'll notice here that our profile component has this **state**, but what if we were rendering another child component? Let's say we had a component called `displayRepos` because we'll eventually have something like that.\n\nThe way we want to get these repositories down to this component is something like this. We could say, \"Repos = this.state.repos.\" I'm going to call this `childRepos` just so you can see the difference.\n\n### Profile.js\n``` javascript\nvar Profile = React.createclass({\n  render: function(){\n    return(\n      <div className=\"row\">\n        <div className=\"col-md-4\">\n          <DisplayRepos childRepos={this.state.repos} />\n        User Profile Component\n        </div>\n        <div className=\"col-md-4\">\n          Repos Component\n        </div>\n        <div className=\"col-md-4\">\n          Notes Component\n        </div>\n      </div>\n    )\n  }\n})\n```\n\nWhat we're doing is we're saying, \"Hey, display repos. You're going to receive this DOS state.repos as child repos.\" Now if we were to go inside of this `DisplayRepos` component, the way we would **access** child repos is by **querying** `this.props.childRepos`.\n\nThrough **props**, we're able to gain **access to data** that's stored in our parents or **stored** in any other **higher** component. The reason I tell you this is because this is kind of how React router works.\n\nRight now, everything's good, and our profile's working, but we actually haven't figured out a way to query our username yet. What we're going to do is let's just `console.log(this.props)`. Let's take a look at that.\n\n### Profile.js\n```javascript\nrender: function(){\n  console.log(this.props);\n  return(...)\n}\n```\n\nIf I'm here, here's our `props` objects. This is everything that's being passed to the `profile` component. You'll notice that one of these is called `params`. This has a **username property** which is Jake.\n\n![this.propsjake](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/this.propsjake.png)\n\nIf I change this, then `params` has a username property which is Tyler McGuinness.\n\nThe way you access route **parameters** with `react-router` is the same way you access any data that's being **passed** down to a **child component**, it's through `this.props`. Let's just display that to the page right here. `this.props.params.username`.\n\n### Profile.js\n``` javascript\nrender: function(){\n  return(\n    <div className=\"row\">\n      <div className=\"col-md-4\">\n        <DisplayRepos childRepos={this.state.repos} />\n      User Profile Component --> {this.props.params.username}\n      </div>\n      <div className=\"col-md-4\">\n        Repos Component\n      </div>\n      <div className=\"col-md-4\">\n        Notes Component\n      </div>\n    </div>\n  )\n```\n\nAgain, the reason it's called the **username** is because that's what we specified inside of our **routes**.\n\nWhen I load this, we should see user profile component and then the name of the route param. I changed this. It updates it.\n\n![Viewing this.props.params.username](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/Viewingthis.props.params.username.png)\n\nOne thing I didn't mention was the way you **display variables** inside of **JSX** is just with this **single curly brace**.\n\nGo ahead and make some more components in your `components` folder. Go ahead and make a `GitHub` folder. Also, make a `notes` folder. In the `GitHub` folder, make two files. The first file is going to be called `repos.js`. The second file will be called `userprofile.js`.\n\nIn the `notes` folder, let's go ahead and make a file called `notes.js`. What these three files are going to be are the component definitions for each of our three components, our user profile component, our user repos component, and our notes component.\n\nLet's go ahead inside of repos. We're going to require React. Then we'll make a new component using `React.createclass`. We'll have it just render something simple. It's going to render `repos`.\n\n### Repos.js\n``` javascript\nvar React = require('react');\n\nvar Repos = React.createclass({\n  render: function(){\n    return(\n      <div> REPOSSS </div>\n    )\n  }\n})\n\nmodule.exports = Repos;\n```\n\nBecause this is going to very similar to the other ones as well, let's just copy and paste. We have `userProfiles`. This is `userProfile`, and then `notes` is going to be `notes`. I'm going to change this to notes.\n\nNow let's head over to our `profile` component and use each of these components we just made. The very first thing we're going to do is let's require all of these to repos is going to be require. We need to go into `GitHub` and then `repos` and then `userProfile`. It's going to be the same thing. It's in the `GitHub` folder. Then our `notes` component is inside the `Notes` folder.\n\n### Profile.js\n``` javascript\nvar Repos = require('./Github/Repos')\nvar UserProfile = require('./Github/UserProfile')\nvar Repos = require('./Notes/Notes')\n```\n\nNow in order to use this, you saw this a little bit earlier, but what we're going to do is simply say `userProfile`. It's self-closing. Then, here, instead of repos, we have our `repos` component. Here instead of notes. We have our `notes` component.\n\n### Profile.js\n``` javascript\nrender: function(){\n  return(\n    <div className=\"row\">\n      <div className=\"col-md-4\">\n      <UserProfile />  \n      </div>\n      <div className=\"col-md-4\">\n        <Repos />\n      </div>\n      <div className=\"col-md-4\">\n        <Notes />\n      </div>\n    </div>\n  )\n```\n\nLet's see if this works. There we go. This is good.\n\n![Displaying Components](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/DisplayingComponents.png)\n\nBut you'll notice here we have user profile, repos, and notes. We also have repos, bio, and notes. What we want to do is we don't just want to render these components. We actually want to **pass data down** to them so that data can be rendered inside of these **child components**.\n\nUser profile, what we're give it first is a `username`. If you'll remember earlier, we can **access** the username of a **route parameter** by doing `this.props.params` and then whatever that route param is called. In this case, it's called usernames.\n\nBut we also want to the `bio` which is currently living on our **state**. Same thing with repos. We're going to pass it down repos as `this.state.repos`. Then notes, `this.state.notes`.\n\n### Profile.js\n``` javascript\nrender: function(){\n  return(\n    <div className=\"row\">\n      <div className=\"col-md-4\">\n      <UserProfile username={this.props.params.username bio={this.state.bio}}/>  \n      </div>\n      <div className=\"col-md-4\">\n        <Repos repos={this.state.repos}/>\n      </div>\n      <div className=\"col-md-4\">\n        <Notes notes={this.state.notes}/>\n      </div>\n    </div>\n  )\n```\n\nNow let's go ahead and go into `userProfile`. Let's just **render the props** that it's getting. Let's return one big div just so we can verify we're getting stuff. We'll say, \"User Profile!\"\n\nThen here let's do the `this.props.username`. Here, let's do bio as `this.props.bio.name`\n\n### Userprofile.js\n``` javascript\nvar Repos = React.createclass({\n  render: function(){\n    return(\n      <div>\n        <p> USER PROFILE! </p>\n        <p> Username: {this.props.username} </p>\n        <p> Bio: {this.props.bio.name} </p>\n      </div>\n    )\n  }\n})\n```\n\nbecause, let's go back to our profile, now let's initialize bio just with some default name. Now if we go, our `userProfile` renders Jake or whatever the route param is. Then we also get bio.\n\nJust real quick, I'm going to go ahead and inside `repos` let's just show that's we're at repos. The repos are the `this.props.repos`. Same thing for notes. We're on notes. Let's render the `this.props.notes`.\n\nLet's see if this works. There we go. Let's go ahead and initialize notes with 1, 2, 3, and repos with a, b, c.\n\n### Profile.js\n``` javascript\ngetInitialState: function(){\n  return {\n    notes: [1,2,3],\n    bio: {\n      name: 'Tyler McGinnis'\n    },\n    repos: ['a','b','c']\n  }\n}\n```\n\nWe're up.\n\n![Finished](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/Finished.png)\n","react-building-a-react-js-app-transitions-with-react-router":"As of right now, our menu we've been creating is just a `bootstrap` menu with a `text` menu. But what we actually want to have happen is we, as we've been doing, want to be able to **enter a username**, and when I click Search GitHub it goes and it **transitions** to this **new route**, passing along the username that we typed in. That's what we're going to do in this video.\n\nLet's go ahead and go back to our code, and let's go ahead and make a new file inside of our `components` folder called `searchGitHub.js`.\n\nThe very first thing, we're going to require **React**. Then what we're going to do is we're going to require the router, because we're going to rely on the **router** to actually do the transition for us between our routes, so require React router.\n\n### SearchGithub.js\n```javascript\nvar React = require('react');\nvar Router = require('react-router');\n```\n\nThen, as always, we make a component using `React.createClass`. Then we **export** this component.\n\nThe `mixins` we're going to use for the transition is the `history` property on the `router` object. Then let's do a `render` function, which returns, it's going to return a **form**, so we're just going to have to bootstrap stuff here.\n\n### SearchGithub.js\n``` javascript\nvar SearchGithub = React.createclass({\n  mixins: [Router.History],\n  render: function(){\n    return()\n  }\n)};\n\nmodule.exports = SearchGithub;\n```\n\nThis form is, whenever it gets **submitted**, is going to run `this.handle.submit`, which we'll create in a second. Then from here, we're going to have two `divs`, one is going to be the `input field`, which is going to be of type `text` and a className of `form-ontrol`. Then as we talked about in the last video, as a ref equal to `this.getRef`, which is going to call this function.\n\nThen what we'll do is we'll have this input `ref` and let's go ahead and say `this.username` ref equals `ref`.\n\n``` javascript\ngetRef: function(ref){\n  this.usernameRef = ref;\n}\n```\n\nThe next container is going to be our button. Whoa. This button is going to be of type `submit`, have a class name of `btn`, `btn-block`, and we'll say `btn-primary` for the color and have a text of Search GitHub, and then we're going to close our button.\n\n### SearchGithub.js\n``` javascript\nrender: function() {\n  return (\n      <div>\n        <form onSubmit={this.handleSubmit}>\n          <div className=\"form-group col-sm-7\">\n            <input type=\"text\" className=\"form-control\" ref={this.getRef} />\n          </div>\n          <div className=\"form-group col-sm-5\">\n            <button type=\"submit\" className=\" btn btn-block btn-primary\"> Search GitHub</button>\n        </form>\n      </div>\n  )\n}\n```\n\nNow, what we need to do is we need to make a function called `handleSubmit`, that will get the value of our `username` ref and **transition** us to our `profile` route, **passing** along that `username` that we're getting from the ref.\n\nInside here, let's go ahead and create a `handleSubmit` method. As usual, let's go ahead and get the `username`, just as we did before. That's going to get us the `username` of this input field, or the **value** of the input field. Then let's go ahead and reset that to an empty string.\n\n### SearchGithub.js\n``` javascript\nhandleSubmit: function(){\n  var username = this.usernameRef.value;\n  this.usernameRef.value = '';\n  this.history.pushState(null, \"profile/\" + username);\n}\n```\n\nThen, this is kind of where the magic happens.\n\nAgain, because we're using a `mixin`, what React is doing is it's taking **any properties** on the `React.History` modular object, that's adding it to our **instance**. One of those properties is called `History`, which has a property called `pushState`.\n\nWhat we can do is `pushState` allows us to **transition** to a **new route**. We, the route we want to transition to is `profile/` plus whatever this username is. Because if you'll remember a few videos ago in our routes config, we said, hey, whenever someone goes to `profile/` whatever username, go ahead and render this profile component.\n\n### SearchGithub.js\n``` javascript\nvar React = require('react');\nvar Router = require('react-router');\n\nvar SearchGithub = React.createclass({\n  mixins: [Router.History],\n  getRef: function(ref){\n    this.usernameRef = ref;\n  },\n  handleSubmit: function(){\n    var username = this.usernameRef.value;\n    this.usernameRef.value = '';\n    this.history.pushState(null, \"profile/\" + username);\n  },\n  render: function() {\n    return (\n        <div>\n          <form onSubmit={this.handleSubmit}>\n            <div className=\"form-group col-sm-7\">\n              <input type=\"text\" className=\"form-control\" ref={this.getRef} />\n            </div>\n            <div className=\"form-group col-sm-5\">\n              <button type=\"submit\" className=\" btn btn-block btn-primary\"> Search GitHub</button>\n          </form>\n        </div>\n    )\n  }\n});\nmodule.exports = SearchGithub;\n```\n\nWhat we're doing here is we're saying, hey, whenever someone clicks on this `handleSubmit` button, go ahead and grab the `username` and then go ahead and take them to this `profile/` whatever that username route is.\n\nThe last thing to do is, let's head over to our main component. Instead of menu here, we are going to render our Search GitHub component, which we need to require.\n\n### Main.js\n``` javascript\nvar React = require('react');\nvar SearchGithub = require('./SearchGithub')\n\nvar Main = React.createclass({\n  render: function() {\n    return (\n      <div className=\"main-container\">\n        <nav className=\"navbar navbar-default\" role=\"navigation\">\n          <div className=\"col-sm-7 col-sm-offset-2\" style={{marginTop: 15}}>\n            <SearchGithub />\n          </div>\n        </nav>\n        <div className=\"container\">\n          {this.props.children}\n        </div>\n      </div>\n    )\n  }\n});\n```\n\nLet's say Search GitHub equals, and we're in the same directory, so let's just get Search GitHub, and now let's check to see if this is working.\n\nWe head over here, we can search for a username and it should redirect us to `/profile/` this username. Then our `notes` component renders, let's give this another test, and there we go.\n\n![Finished](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/08-finished.png)\n","react-building-a-react-js-app-up-and-running-with-react-and-webpack":"In this video we're going to build our very first **React component**. But before we do that, we need to do a few other things. The very first thing I'm going to do is run `npm init`.\n\n### Terminal\n``` Bash\nnpm init\n```\n\nWhat this is going to do, and I'm just pressing enter here to get through all the commands, is it's going to allow us to use npm to **require modules** that we need, specifically modules like React. So what I'm doing here is I'm installing a specific version of React, this is the latest version as of today, but that might change.\n\n### Terminal\n``` Bash\nnpm install --save react\n```\n\nSo this is just future-proofing this series a little bit. When this is done, what you'll notice is that we have this `node_modules` folder, and inside that `node_modules` folder we now have React. We can see if we take a look inside of that, so React is right here. So now any time we want to use React, we can just `require` it and we'll have that available to us.\n\nOne more thing we need to install is this thing called the **ReactDOM**. The same thing, I'm going to install a specific version number, and we'll talk a little bit more about what exactly is ReactDOM later in this lesson.\n\n### Terminal\n``` Bash\nnpm install --save react-dom\n```\n\nNow we're going to install a bunch of **dependencies** related to **Babel**. Babel is a JavaScript compiler that's going to let us write **JSX**, which we'll talk about in a second, but it's also going to let us write **ES2015 or ES6** as I'll refer to it.\n\n### Terminal\n``` Bash\nnpm install --save babel-core babel-loader babel-preset-es2015 babel-preset-react\n```\n\nBasically what we're doing here with Babel is we will write some code, Babel will compile that for us into something that the browser can read. So let's look at exactly how Babel is going to help us. Here we have some normal React code, we have some JavaScript stuff, and then it looks like what we have here is HTML.\n\nThis is actually called **JSX**, and what JSX does is it allows us to write HTML-ish looking code inside of our JavaScript, and now that's going to sound a little weird, and it might throw up some red flags in your head, but it's actually really convenient, and you'll probably learn to love it as you get more used to React. Now you'll notice inside of our `node_modules` folder we have all this Babel stuff, and we also have our React code.\n\nThe next thing I'm going to do is make a folder called `public`, and then inside that folder, I'm going to make a new `index.html` file.\n\n### Terminal\n``` Bash\nmkdir public\ncd public/\nls\ntouch index.html\n```\n\nIf we head over to our code, this `index.html` file is going to be basically the **root view** of our application. So you'll notice here I'm just pasting in this, we have bootstrap, and we have a `div` with an `ID` of `app`, and then we have the only script that we're going to include is this `bundle.js` file.\n\n### index.html\n``` html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <title>React Github Notetaker</title>\n  <link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\">\n</head>\n<body>\n  <div id=\"app\"></div>\n  <script src=\"bundle.js\"></script>\n</body>\n</html>\n```\n\nEventually what's going to happen is we want to take all of our code and all of our components, we want to put them through a process that's going to **transpile** our **JSX** into **normal JavaScript**, and then we want to spit all of that out in one file called `bundle.js` inside of our public folder. To do that, what we're going to do is we're going to use this very nice tool called **webpack**.\n\nSo I'm going to create a `webpack.config.js` file, and if you haven't used webpack before, what you'll need to do is head over to your terminal and run `npm install webpack -g`, and what that's going to do is it's going to save webpack as a **global module** on your computer, but since I've already done that, we don't really need to do that.\n\n### Terminal\n``` Bash\ntouch webpack.config.js\nnpm install webpack -g\n```\n\nHeading back to our `webpack.config` file, we are going to export an object that has all of our webpack configuration stuff. This is going to make a lot of sense as we start going through it.\n\nThe very first thing we want to do is we need to tell webpack where our **root component** is. Because if you think about React, and we'll talk a lot more about this, but React is basically composed of different components and there's always **one root component** that's going to **render** all of its **children components**. So we're pointing webpack to that root component so that it knows where to start processing all of our JSX.\n\nThe next thing we're going to need to do is we want to tell webpack where after it's done transpiling everything, and combining it all into one file, where to puke out that new file. So what we're going to say is once you're done compiling this, or transpiling this component and all of the children components, we want you to take that new code and throw it into `bundle.js` in the `public` folder. Then the last thing we're going to do is we need to tell it what to actually do with the main JS code and all of its children components.\n\nWhat we're going to do, is we're going to use a loader, and this loader, it's the **Babel loader** which we downloaded earlier. Now we need to tell Babel exactly what transformation we'd like it to do to our code. If you remember earlier we downloaded a bunch of npm packages related to Babel. What we're going to do now is go ahead and create a `presets` property on this `query` object. **Presets** is all the **transformations** that **Babel** is going to do to our **code**.\n\nSo one preset we installed earlier was the `React` preset, then the other one which we're not going to use initially but we're going to use later on in this lesson is called `ES2015`, basically that's going to allow us to write **ES6** code.\n\n### webpack.config.js\n``` javascript\nmodule.exports = {\n  entry: \"./app/components/Main.js\",\n  output: {\n    filename: \"public/bundle.js\"\n  },\n  module: {\n    loaders: [\n      {\n        test: /\\.jsx?$/,\n        exclude: /(node_modules|bower_components)/,\n        loader: 'babel',\n        query: {\n          presets: ['react', 'es2015']\n        }\n      }\n    ]\n  }\n}\n```\n\nNow what we need to do, is let's go ahead and create our very first **component**. Let's make a new folder called `app` which is where all of our application code will live, and then let's make a new folder called `components` which all of our components will live in, and now let's go ahead and make a new file called `main.js`.\n\n### Terminal\n``` Bash\nmkdir app\ncd app/\nmkdir components\ncd components/\ntouch Main.js\n```\n\nNow up to this point what's going to happen is when we create this `main.js` component, you'll notice here that's just this entry. **Webpack** is going to say, \"Hey, I have this `main.js` component, I'm going to take this component, I'm going to run it through these **transformations**, and then I'm going to **spit** it out in this `public/bundle.js` file.\" The very first thing is we're going to `require` React and we're able to do this because earlier we npm installed React, so now if we require React we have that.\n\nThen I'm going to create a new variable called `main`, and I'm going to set it equal to `react.createClass`. What `react.createClass` does is it creates a **React component** for us, so there's a few properties you can pass in. The one that we're going to talk about in this video is called `render`. What render does is it specifies what the **UI** looks like for this specific element. So we're going to have something very basic that just says, `Hello World`.\n\n### Main.js\n``` javascript\n  var React = require('react');\n\n  var Main = React.createClass({\n    render: function(){\n      return(\n        <div>\n          Hello World\n        </div>\n      )\n    }\n  });\n```\n\nSo when this component gets rendered to the view, and eventually we'll do something like this to render it. When this gets rendered to the view it's going to show `Hello World`. Now we need to render this main component to the view. If you remember earlier we npm installed this thing called `ReactDOM`. What's cool about React is you're able to do things like server-side rendering. So what ReactDOM does, it says, \"Hey React, we are going to render this component on the client with React DOM and not on the server.\"\n\nNow what we need to do is we're going to say `react-dom.render`, we need to then give it our **main component**, our main parent component that we're rendering, and we need to tell it where to **render** to. If you'll remember earlier we create this guy, this div with an id of apps, so all we're going to do is say `document.getElementByID` and then select apps, and then what that will do is it will go ahead and grab this element and render the main component to it.\n\n### Main.js\n``` javascript\n  var React = require('react');\n  var ReactDOM = require('react-dom');\n\n  var Main = React.createClass({\n    render: function(){\n      return(\n        <div>\n          Hello World\n        </div>\n      )\n    }\n  });\n\n  ReactDOM.render(<Main />, document.getElementByID('app'))\n```\n\nNow head over to your terminal and go ahead and run webpack, `webpack -w`, so it looks like everything's good.\n\n### Terminal\n``` Bash\nwebpack -w\n```\n\n Now let's go ahead and open up this `index.html` file on the browser and what we should see is `Hello World`.\n\n ![Hello World](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/02-finish.png)\n","react-building-a-react-js-app-using-reactfire-to-add-data-persistence":"Now what we're going to do in this video is we're going to hook up our **firebase** so we can start persisting these notes, and we're going to build out the rest of this `notes` component so that we get a nice **little unordered** list of all of our `notes` that are in firebase.\n\n![Notes Component](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/notes.png)\n\nSo let's go ahead and jump to our code, and what we're going to do first is we are going to use this thing called **ReactFire** that Firebase made that makes it so that our **component state** can be bound to a Firebase **endpoint**.\n\n### Terminal\n``` bash\nnpm install --save reactfire@0.5.1\n```\n\nMeaning whenever a Firebase **endpoint changes**, our state will **automatically** update with the **data** that's there. So head to your terminal and go ahead and install it's called `ReactFire`. Then once that finishes, as a side note really quick you might be wondering why we're getting this error, that's because we've installed `webpack` globally so that we can use the command line tools, but we haven't installed it locally. It's not really necessary, but I'm going to npm install it locally just so this error goes away.\n\n### Terminal\n``` bash\nnpm install --save-dev webpack\n```\n\nSo what we'll do is go ahead and run `npm install` dev webpack. That will make it so whenever we install new packages this error isn't getting thrown. Go ahead and head over to your `profiles.js` file and then require `ReactFireMixin`. You can do it just by requiring ReactFire so what we're going to do, as the name suggests, is we are going to add `ReactFire` as a **mixin** into your **component**.\n\nWhat we're going to do is go ahead and give your class a `mixins` property, and then the value is going to be an array with `ReactFireMixin` as the first item in that array. What this is doing is it's going to take your instance, it's going to **mixin** some certain **functionalities** so that we can use that new functionality. So this is literally taking the `this` keyword of your class and it's adding a few `ReactFire` mixin methods onto that, so that we can use those later.\n\n### Profile.js\n``` javascript\nvar ReactFireMixin = require('reactfire');\n\nvar Profile = React.createClass({\n  \tmixins: [ReactFireMixin],\n```\n\nNow what we want to do is we're going to introduce a brand new **lifecycle event** called `componentDidMount`. Here is where you're going to want to all your **Ajax requests**, it's where you're going to want to set up all your Firebase **listeners**, the `componentDidMount` lifecycle event will be called right **after** your component mounts to the **view**. So it's pretty straightforward, but basically when the component mounts this callback will be called.\n\nWhat we're going to do here is the very thing we want to do is we're going to create a new `reference` to our Firebase. If you've never used Firebase before, what we're doing here is we're going to create a new **instance** of Firebase and we're going to **pass** it the **URL** of where our **project** is located. So if I head over to my Firebase dashboard, you'll notice all I did was create a new project and you'll notice there's this URL.\n\n![Firebase URL](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/firebase.png)\n\nThis URL is kind of the **base** of our project, so if I head back over to my code all I'm doing here is I'm saying, \"Hey, create me a new instance of Firebase which is going to return me an **object** full of all these Firebase-y **type properties**. I'm going to save that on my instance under the ref property. Then once I do that, I'm going to then call `bindAsArray`, and the reason that's this keyword now has a `bindAsArray` property, is because that's exactly what our ReactFire **mixin** did.\n\n### Profile.js\n```javascript\ncomponentDidMount: function(){\n\tthis.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n\tthis.bindAsArray();\n}\n```\nIt took our context, it took our `this` keyword and added a few properties to it and one of those is `bindAsArray`. BindAsArray takes two arguments the **first** argument is a **reference** to your Firebase, and the **second** argument is the **property on your state** that you want to bind the Firebase data to. So looking back at Firebase you'll notice that we have our endpoint and basically at our **root location** we have all these user names. If I come and click on one of these user names, notice the **URL changed**.\n\n![Firebase User](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/github-notetaker-egghead/user.png)\n\nThis gives us a little bit of insight into how we want to `bind` to the specific property in our state, because if we're here and we're at Tyler's profile, we want to bind to `\\tyler`, or if we come here and the user name is `\\jclingwall`, then we want to get all of jclingwall's information. So what we're going to do is let's go ahead and make a `childRef` which is `this.ref.child` and then we're going to pass it the `username` property.\n\n### Profile.js\n```javascript\ncomponentDidMount: function(){\n\tthis.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n\tvar childRef = this.ref.child(this.props.params.username);\n\tthis.bindAsArray();\n}\n```\nSo `.child` is a Firebase thing, and it says hey dial 1 if this is our **root**, and it is because that's a reference we created with just the this specific URL. If we want it to then go into `\\jclingwall`, notice how it goes `\\jclingwall`. That's exactly what we're doing here, is we're basically just saying take our ref and then go one deeper into whatever this is, jclingwall, tylermcginnis, whatever it is.\n\nNow what we're going to do is we're going to pass `bindAsArray` our `childRef` which is again, a reference to this **specific username's** endpoint in Firebase, and then we're going to pass it the property on the state that we want to bind to which is `notes`. So now, when this **component mounts** it's going to set up this **binding** between our local state and Firebase, and `this.state.notes` should be the data that's located at this **specific Firebase endpoint**.\n\n### Profile.js\n```javascript\ncomponentDidMount: function(){\n\tthis.ref = new Firebase('https://github-note-taker.firebaseio.com/');\n\tvar childRef = this.ref.child(this.props.params.username);\n\tthis.bindAsArray(childRef, 'notes');\n}\n```\nWhat's nice as well, is whenever this Firebase endpoint changes, that's going to update our **local state** as well. But what we don't want to do is **add** all these **Firebase listeners** and never get rid of those. So what we're going to do is introduce a brand new lifecycle event called the `componentWillUnmount`.\n\n### Profile.js\n```javascript\ncomponentWillUnmount: function(){\n\tthis.unbind('notes');\n},\n```\nWhenever this component unmounts, what we're going to do is we're going to call the `unbind()` property on ReactFire and we're going to pass it `notes` so that it will remove that `listener` so it's not always listening and not always trying to **update** our state even after our component has **moved on**. Before we forget let's go ahead and `require Firebase`, and also `npm install` Firebase so that we can do line 18 here. So I'm going to go ahead save our `Firebase = require Firebase`.\n\n**Whoa**. Now then I'm going to head over here to my terminal and I'm going to npm install Firebase.\n\n### Terminal\n``` bash\nnpm install --save firebase@2.3.2\n```\n\nNow that we have Firebase, let's go ahead and make some changes to our **UI**. So the very first thing I'm going to do, and this is just preparatory for future lessons, is notice here we're **passing** in the username to `userProfile`, let's go ahead and do that for our repos component. So our `repos` component has access to the username, let's also do that for our `notes` component.\n\nI'm also going to delete `this.props` on here, so that's not clouding anything that we see.\n\n### Profile.js\n```javascript\nrender: function(){\n    return (\n      <div className=\"row\">\n        <div className=\"col-md-4\">\n          <UserProfile username={this.props.params.username} bio={this.state.bio} />\n        </div>\n        <div className=\"col-md-4\">\n          <Repos username={this.props.params.username} repos={this.state.repos}/>\n        </div>\n        <div className=\"col-md-4\">\n          <Notes username={this.props.params.username} notes={this.state.notes} />\n        </div>\n      </div>\n```\nThen let's go ahead and go over to our `notes` component and instead of just puking the notes to the screen, **React** is actually going to throw an error in React .14 because you can't just puke a whole array to the screen, it needs to be a string or something like that. So what we're going to do is let's go ahead and remove this line,\n\n### Notes.js\n``` javascript\n<p>{this.props.notes}</p>\n```\n\nand now let's go ahead and just `console.log` notes and then `this.props.notes`.\n\n### Notes.js\n``` javascript\nvar Notes = React.createClass({\n\trender: function(){\n\t\tconsole.log('Notes: ', this.props.notes)\n```\n\nSo now what we should see is if we go and refresh this, let's go ahead and start `webpack`, all right everything's good. If we refresh this what we should see is it's logging our notes to the console. You'll notice here that it logs **1,2,3** because what we've done is in our `profile` view we've set the **initial** notes values to an array of 1, 2, and 3.\n\nThen what happens is Firebase comes and sets our **listeners**, and then eventually we get a bunch of our notes like this, which has a **key value** which is the key in our key **property**, which is the key of the **specific** item in Firebase, and then a **value** property which is the item at that value.\n\nSo what's cool about Firebase, this is all **real time**. So if I come in here and I say change this from \"Hi\" to \"Hello\" what we should see is over here, we now have brand new notes, and we see \"Hello.\" So head back over to your code and let's finish formatting the `notes` component.\n\nFirst, notice we're passing notes to our `notes` component, and we are here and so let's go ahead and change this around a little bit. Very first thing is instead of just saying notes, I'm going to have an `H3` tag, and we're going to say notes for `this.props.username`. Then below that, let's go ahead and instead of making it so this component is worried about styling everything, let's go ahead and make a brand new component. So here's our fixed example.\n\n### Notes.js\n``` javascript\nvar Notes = React.createClass({\n\trender: function(){\n\t\tconsole.log('Notes: ', this.props.notes)\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<h3> Notes for {this.props.username} </h3>\n\t\t\t</div>\n```\nWe could have everything just be in one component, but that's kind of not the point of **React**, we want **multiple** components and we want to be able to have **reusable** components. So let's make a component which takes in an array of items and will loops over those array and create an unordered list for us. If we head back over to our code, let's go ahead and inside of our `notes` folder, let's create a new file called `NotesList.js`.\n\nHere we're going to require React and we're going to create a component called `NotesList` and let's go ahead and `module.export` that. All right, so the **UI** for this component is going to be pretty simple. We are going to return an unordered list has a class name of `list-group` which is just a bootstrap thing. Here what we want to do is we want to have a bunch of `li` tags that we want one `li` tag for **each** item in the array that we're going to **pass** this component.\n\n### NotesList.js\n``` javascript\nvar NotesList = React.createClass({\n\trender: function(){\n\t\tvar notes = this.props.notes.maps(function(note, index){\n\n\t\t})\n\t\treturn (\n\t\t\t<ul className=\"list-group\">\n\n\t\t\t</ul>\n\t\t)\n\t}\n});\n```\n\nSo what we're going to do is we are going to **map** over the notes that we're getting from the **parent** component. So if you've never used map before, basically all it does is it allows you to **iterate** through every item in an array and **modify each** item in an array **separately**, and then spit out a new array with each item modified. So say for example we had an array of 1, 2, and 3.\n\nWhat we can do is we could call `.map()` on that array, and pass it a callback function, and then what we can do is if we `return item + 1`, the very first iteration or the very first time this callback is ran, `item` is going to be `1`, or the first item in our array, and `index` is going to be `0`, so if we `return item + 1`, eventually we're going to have a brand new array that looks like 2,3, and 4 getting returned from `this.map` function.\n\n### NotesList.js\n``` javascript\n[1,2,3].map(function(item, index){\n\treturn item + 1\n\t}); //[2,3,4]\n```\nSo imagine if these were all now notes, and if we were mapping over these notes what that is going to return us is a brand new array after we've modified each note. So what we're doing is if these were `this.props.notes`, what we can do is we can wrap each note in a **list item** so that we then get an **array** of list items with some `note` inside of it.\n\n### NotesList.js\n``` javascript\nthis.props.notes.map(function(item, index){\n\treturn <li> {item} </li>\n\t}); //[<li>Notes</li>,3,4]\n```\nSo what we're going to do is for each item in the array we're going to return a new list item with a class name of `list-group-item`, it's going to have a key of the `index`, and index is just 0,1,2,3, just normal indices for arrays, and then inside of this **list item**, we are going to show the note at `.value`, and you might be asking why is .value? If you remember, what Firebase does is it wraps each item in an object that has a key property and a .value property.\n\n### NotesList.js\n``` javascript\nvar NotesList = React.createClass({\n\trender: function(){\n\t\tvar notes = this.props.notes.maps(function(note, index){\n\t\t\treturn <li className=\"list-group-item\" key={index}>{note['.value']}</li>\n```\n\nWe only care currently about this `.value` property. Now let's go ahead and close our `li` tag, and now we have notes which is an array of list items, and we will just throw that here, so inside of our **unordered list**, we have an array of **list items**.\n\n### NotesList.js\n``` javascript\n<ul className=\"list-group\">\n\t{notes}\n</ul>\n```\nSo the last thing we need to do is head back over to our `notes` component and let's go ahead and require `NotesList`, and then we want to...let's delete all this stuff.\n\n### Notes.js\n``` javascript\nvar React = require('react');\nvar NotesList = require('./NotesList');\n\nvar Notes = React.createClass({\n  render: function(){\n    return (\n      <div>\n        <h3> Notes for {this.props.username} </h3>\n        <NotesList notes={this.props.notes} />\n      </div>\n    )\n  }\n})\n\nmodule.exports = Notes;\n```\nInstead, we want to use `NotesList` and we are going to pass it `notes` which is coming down from our **parent** component. So notice that you can **pass down** properties as far as you want. So our `notes` originally started at our `profile`, then go to our `notes` component, and then we're **passing** them down to our `NotesList` component. Let's go ahead and close this `NotesList` component, check that webpack is still working, it is, and in our app we should see if we hit refresh all of our items that are in Firebase.\n","react-building-a-react-js-app-utilizing-stateless-function-components":"...I was going to end this series at video number 16 but, as **React** keeps adding more features, I can go ahead and keep adding new videos. What we're going to do in this video is we're going to walk through a **new feature** as of React **0.14** which is called **stateless functional** components.\n\nWhat **stateless functional** components are is you'll notice here that throughout a lot of our code, we have a lot of **components** that simply just have a `render` method. We have `Home`. We have `Main`. We have some other components as well. These components are really simple.\n\nIdeally, if you're doing a good job of programming in React, you're going to have a lot of components that simply take in data as props. For example, this `Main` component, all it does is it **takes in** some **props**, and it **displays** that to the **view**.\n\nSometimes it would be nice to not have to create a whole class if you want to simply make a component. What we're going to do here is we're going to walk through all of our components and modify them just a little bit to make them a little bit more clean.\n\nI'm going to go ahead and simply make a function here. I'm using the **ES6 Arrow** syntax, which we talked about a few videos ago, but this is fundamentally just a function. The very **first argument** that's going to be passed to our function is **props**. In this example, we're not going to have any props.\n\n### Home.js\n``` javascript\nexport default function Home () {\n  return (\n    <h2 className=\"text-center\">\n      Search By Github Username Above\n    </h2>\n  )\n}\n```\n\nWhat we can do is this, where we can take the `render` method of our component. If our component, *one*, **doesn't** have any **state** and, *two*, only has a `render` method, we can then go ahead and make that just a function. Now this function is pretty much the exact same thing as our class we had earlier. It'll **behave** the **exact** same way to **React**.\n\nLet's go ahead and test this. There we go. Everything still works. Let's go ahead and fly through some of these other components. Let's go to `Main`. Then I'm going to **create a function** here, which is just going to **return** our `render` method. You'll notice now that this function actually takes in some **props**. What **React** does is it **provides props** as the **first argument** into your function.\n\nWhat I'm going to do here is kind of a mix of two **ES6** features. It's a mixture of **object destructuring**, which we talked about a few videos ago, and it's also a mixture of this thing called **default parameters**.\n\n### Main.js\n``` javascript\nconst Main = ({children, history}) => {\n  return (\n    <div className=\"main-container\">\n      <nav className=\"navbar navbar-default\" role=\"navigation\">\n        <div className=\"col-sm-7 col-sm-offset-2\" style={{marginTop: 15}}>\n          <SearchGithub history={history}/>\n        </div>\n      </nav>\n      <div className=\"container\">\n        {children}\n      </div>\n    </div>\n  )\n}\n```\n\nWhat we can do here is if you have a **function** that takes in an **object**, you can go ahead and use **open curly brace**, **close curly brace**, and put in the **properties** of that **object**. Then you can **access** the **properties** of that object inside of your function simply as the **variable** that you used here.\n\nAgain, it would be the exact same thing as doing something like that. Instead, we can go one level deeper. Go ahead and take off history and children from `this.props` and go like that. It's pretty clean.\n\nLet's go ahead and do the rest of our components real quick. Here I'm going to make a `Repos` function. Let's go ahead and grab our `render` method. Notice here, too, this function has `propTypes`. It behaves the exact same way. We can go ahead and stick a **prop type** property on our **function** itself. It'll still behave normal.\n\n### Repos.js\n``` javascript\nconst Repos = ({repos}) => {\n  return (\n    <div>\n      <h3> User Repos </h3>\n      <ul className=\"list-group\">\n        {repos.map((repo, index) => {\n          return (\n            <li className=\"list-group-item\" key={repo.name}>\n              {repo.html_url && <h4><a href={repo.html_url}>{repo.name}</a></h4>}\n              {repo.description && <p>{repo.description}</p>}\n            </li>\n          )\n        })}\n      </ul>\n    </div>\n  )\n}\n```\n\nIn this one, we have `this.props.repos`. I'm going to go ahead and take off `this.props` and throw in `repos` up here. Now let's do `UserProfile`. I'm going to make a function. This function is going to take in some **props**, which is a `bio` object. Then we move our `render` method up. Now I'm going to get rid of `this.props`.\n\n### UserProfile.js\n``` javascript\nconst UserProfile = ({bio}) => {\n  return (\n    <div>\n      {bio.avatar_url && <li className=\"list-group-item\"> <img src={bio.avatar_url} className=\"img-rounded img-responsive\"/></li>}\n      {bio.name && <li className=\"list-group-item\">Name: {bio.name}</li>}\n      {bio.login && <li className=\"list-group-item\">Username: {bio.login}</li>}\n      {bio.email && <li className=\"list-group-item\">Email: {bio.email}</li>}\n      {bio.location && <li className=\"list-group-item\">Location: {bio.location}</li>}\n      {bio.company && <li className=\"list-group-item\">Company: {bio.company}</li>}\n      {bio.followers && <li className=\"list-group-item\">Followers: {bio.followers}</li>}\n      {bio.following && <li className=\"list-group-item\">Following: {bio.following}</li>}\n      {bio.following && <li className=\"list-group-item\">Public Repos: {bio.public_repos}</li>}\n      {bio.blog && <li className=\"list-group-item\">Blog: <a href={bio.blog}> {bio.blog}</a></li>}\n    </div>\n  )\n}\n```\n\nI think we just have one or two more. You'll notice this one has some methods on it, so we're not going to do that one. We are going to do `Notes`, which takes in a few things. It takes in a `username`, it takes in `notes`, and it takes in an `addNote` method. Then grab our **return statement**, throw that into here, and format it. Go ahead and update `this.props`. All right.\n\n### Notes.js\n```javascript\nconst Notes = ({username, notes, addNote}) => {\n  return (\n    <div>\n      <h3> Notes for {username} </h3>\n      <AddNote username={username} addNote={addNote} />\n      <NotesList notes={notes} />\n    </div>\n  )\n}\n```\n\nThen, the very last one, I believe, is `NotesList`. We have our function. Then we grab our `render` method. Notice here that I'm using the **Arrow** syntax for my functions. You don't need to do that. You can just use the regular function keyword. Since we've gone all **ES6**, I'm going to go ahead and do that. Then here we're going to have `notes`.\n\n### NotesList.js\n``` javascript\nconst NotesList = ({notes}) => {\n  return (\n    <ul className=\"list-group\">\n      {notes.map((note, index) => (\n        <li className=\"list-group-item\" key={index}>{note}</li>\n      ))}\n    </ul>\n  )\n}\n```\n\nThis looks great. We're good. Now we have everything functioning the exact same, but now instead of having **classes** all over the place or even using `createClass`, instead we're just having these **lightweight** functions that **return** us whatever our down looks like for this component.\n"}
{"01singleImmutableStateTree.md":"The first principle of **Redux** is whether your app is a really simple one like this `counter example`, or a complex application with a lot of UI, and change of state, you are going to represent the whole state of your application as a single JavaScript object.\n\nAll mutations, and changes the state in **Redux** are explicit. It is possible to keep track of all of them. In this case, I am logging every state change in the application in the console. You can see that, in the `counter example`, there isn't really much state to keep track of so it can be represented by a JavaScript number.\n\n![Numbers Showing State](./Images/NumbersShowingState.png)\n\nHere is a different example, a list of independent counters that I can add and remove. In this case, a single number is not enough to represent the state of the application, so we use an array of JavaScript numbers. In a more complex application, there is more state to keep track of.\n\n![Multiple Counter State](./Images/MultipleCounterState.png)\n\nThis is a typical `to-do app`, where I can add to-dos, I can cross them as completed ones, and I can change their current filter. Looking back at the history of the state changes, we can see that the initial state of the app was a JavaScript object, containing an array under the to-do string, and a string seen show all, under visible, the filter.\n\n![To-Do App State](./Images/ToDoAppState.png)\n\nWhen I added the first to-do, it was added to the to-dos array, inside our state object. The to-do itself, is described by a plain child script object, saying it was not completed, and the text was saved. Every further change that the app, whether when I was crossing out the to-dos, or when I changed the visibility filter, resulted in this change to this state object, described in our whole application.\n\nNow you know the first principle of **Redux**, which is that, **everything** that changes in your application, including the **data** and the **UI state**, is contained in a **single object**, we call the state or the state tree.\n","02describingStateChangeWithActions.md":"The second principle of **Redux** is that the **state tree** is **read only**. You cannot modify or write to it. Instead, anytime you want to change the state, you need to **dispatch** an **action**.\n\nAn **action** is a **plain JavaScript object** describing the change. Just like the **state** is the minimal representation of the data in your app, the **action** is the minimal representation of the change to that data.\n\n![Describing Actions](./Images/DescribingActions.png)\n\nThe structure of the action object is up to you. The only requirement is that it has a **type property**, which is not undefined. We suggest using **strings**, because they are **serializable**.\n\nIn different apps, you're going to have different types of actions. For example, in a counter app we only have increment and decrement actions. We don't pass any additional information, because this is all that is needed to describe these changes.\n\nBut say, for a counter release example, we have more actions. We have add counter action, we have a remove counter action, and anytime I change the individual counter, you can see that the increment and the decrement actions now have index. Because we need to describe which particular counter was changed.\n\n![Multiple Actions](./Images/MultipleActions.png)\n\nThis approach scales well to medium and complex applications. Anytime I add a todo, the components don't really know how exactly it's been added. All they know is that they need to dispatch an action with a type, `add_todo`, and the text of the todo and a `sequential ID`.\n\nIf I toggle a todo, again, the components don't know how it happens. All they need to do is to dispatch an action with a type, `toggle_todo` and pass in the `ID` of the todo I want to toggle.\n\n![Complex Example](./Images/ComplexExample.png)\n\nThe same is true for the `visibilityFilter`. Anytime I click on this control to change the currently visible todos, what really happens is this component **dispatches an action** with a type, `SET_VISIBILITY_FILTER`, and pass in the desired filter string, filter field.\n\nBut these are all plain objects, describing what happens in a app.\n\nNow you know the second principle of **Redux** -- the state is read only. The only way to change the **state tree** is by dispatching an **action**. An action is a plain JavaScript object, describing in the minimal way what changed in the application. Whether it is initiated by a network request or by user interaction, any **data** that gets into the **Redux** application gets there by **actions**.\n","03pureAndImpureFunctions.md":"Before we proceed any further, it's important that you understand the difference between the **pure** and **impure** functions. The pure functions are the functions whose returned value depends **solely** on the values of their **arguments**.\n\n``` javascript\n// Pure function\nfunction square(x){\n  return x * x;\n}\n```\n\nPure functions do not have any **observable side effects**, such as network or database calls. The pure functions just calculate the new value. You can be confident that if you call the pure function with the same set of arguments, you're going to get the same returned value. They are **predictable**.\n\nAlso, pure functions do not modify the values passed to them. For example, `squareAll` function that accepts an array does not overwrite the items inside this array. Instead, it returns a new array by using `items.map`.\n\n``` javascript\n// Pure function\nfunction squareAll(items){\n  return items.map(square);\n}\n```\n\nOn the opposite, impure functions may call the database or the network, they may have **side effects**, they may operate on the **DOM**, and they may **override** the values that you pass to them.\n\n``` javascript\n// Impure functions\nfunction square(x){\n  updateXInDatabase(x);\n  return x * x;\n}\nfunction squareAll(items){\n  for (let i = 0; i < items.length; i++) {\n    items[i] = square(items[i]);\n  }\n}\n```\n\nThis is going to be an important distinction because some of the functions that you're going to write in **Redux** have to be **pure**, and you need to be mindful of that.\n","04theReducerFunction.md":"You might have heard that the **UI** or the **view layer** is most predictable when it is described as a **pure function** of the application state. This approach was pioneered by **React** but is now being picked up by other frameworks, such as Ember and Angular.\n\n![The Reducer](./Images/TheReducer.png)\n\n**Redux** complements this approach with another idea, that the **state mutations** in your app need to be described as a pure function that takes the previous state and the action being dispatched and returns the next state of your application.\n\nInside any **Redux** application, there is one particular function that takes the state of the whole application and the action being dispatched and returns the next state of the whole application. It is important that it does not modify the state given to it. It has to be pure, so it has to return a new object.\n\nEven in **large applications**, there is still just a **single** function that manages how the next state is calculated based on the previous state of the whole application and the action being dispatched. It does not have to be slow.\n\n![Large App Example](./Images/LargeAppExample.png)\n\nFor example, if I change the `visibilityFilter`, I have to create a new object for the whole state, but I can keep the reference to the previous version of the todos state, because it has not changed when I changed the `visibilityFilter`. This is what makes **Redux** fast.\n\nNow you know the third and the **last principle of Redux**. To describe **state mutations**, you have to write a function that takes the **previous state** of the app, the action being **dispatched**, and returns the **next state** of the app. This function has to be pure. This function is called the **Reducer**.\n","05writingCounterReducer.md":"The first function we're going to write is the **reducer** for the counter example. Reducer accepts state and action as arguments and returns the next state. Before jumping into the implementation, we're going to make certain assertions using Michael Jackson's Expect library. We're going to assert that when the state of the counter is zero and you pass an `INCREMENT` action it should return one. Similarly it should return two when this state is one and you `INCREMENT`.\n\n``` javascript\nfunction counter(state, action){\n  return state;\n}\n// Tests\nexpect(\n  counter(0, { type: 'INCREMENT' })\n).toEqual(1);\n\nexpect(\n  counter(1, { type: 'INCREMENT' })\n).toEqual(2);\n\nexpect(\n  counter(2, { type: 'DECREMENT' })\n).toEqual(1);\n\nexpect(\n  counter(1, { type: 'DECREMENT' })\n).toEqual(0);\n\nexpect(\n  counter(1,{ type: 'SOMETHING_ELSE' })\n).toEqual(1);\n\nconsole.log('Tests passed!')\n```\n\nWe're going to add a couple of tests that test how `DECREMENT` works, which is that it decrements from two to one and from one to zero and we're going to add a log to tell if our tests are successful.\n\n![Tests Failed](./Images/TestsFailed.png)\n\nIf you ran this test, they're actually going to fail because we haven't even begun to implement our reducer. We're going to start by checking the `action.type` and if the `action.type` is `INCREMENT` we're going to return state plus one, but if it is `DECREMENT` we're going to return state minus one.\n``` javascript\nfunction counter(state, action) {\n  if(action.type === 'INCREMENT'){\n    return state + 1;\n  } else if (action.type === 'DECREMENT') {\n    return state - 1;\n  }\n}\n```\nIf you run the tests we will find that this is enough to get them to pass. However, there are still some flaws in our current implementation of the **counter reducer**. For example, I think that if we **dispatch** an action that it does not understand, it should return the **current state** of the application.\n\n![Tests Passed](./Images/TestsPassed.png)\n\nHowever, if we check for that we will see that this test fails, because we currently don't handle **unknown actions**. I'm going to add an else clause that returns the **current state**. The tests pass now.\n``` javascript\nelse {\n  return state;\n}\n```\nAnother issue is that while the **reducer** is normally in control of the application state, currently it does not specify the **initial state**. In the case of counter example that would be zero. The convention we use in **Redux** is that if the reducer receives `undefined` as the state argument, it must return what it considers to be the initial state of the application. In this case it will be zero.\n``` javascript\nfunction counter(state, action) {\n  if (typeof state === 'undefined'){\n    return 0;\n  }\n}\n\nexpect(\n  counter(undefined, {})\n).toEqual(0);\n```\nNow come a few cosmetic tweaks. I'll replace this bunch of tweaks with a **switch statement** and I'm going to replace this condition with **ES6** default argument, which looks better. I'm also going to replace the function declaration with an **arrow function**, which has clearer semantics in ES6.\n``` javascript\nconst counter = (state = 0, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1;\n    case 'DECREMENT':\n      return state - 1;\n    default:\n      return state;\n  }\n}\n```\n","06storeMethods.md":"\nI added **Redux** to our application as a script act from CDNJS. This is the UMG build, so it exports a single global variable called **Redux**, with a capital R. In real applications, I suggest you to use NPM instead and a module bundler like **webpack** or **Browserify**, but the UMG build will suffice for our example.\n\nI'm going to need just a single function from **Redux** called `createStore`. I'm using ES6 **destruction syntax** here. It's equivalent to writing, \"`var createStore = Redux.createStore`\" or, if you use **NPM** and something like **Babel** to transpile your ES6, you can write, \"`import createStore`,\" notice the parenthesis, \"from Redux.\"\n``` javascript\nconst { createStore } = Redux;\n// var createStore = Redux.createStore;\n// import { createStore } from 'redux';\n```\nThis store binds together the three principles of **Redux**. It holds the current application's state object. It lets you dispatch **actions**. When you create it, you need to specify the **reducer** that tells how state is updated with **actions**.\n``` javascript\nconst store = createStore(counter);\n```\nIn this example, we're calling `createStore` with counter as the **reducer** that manages the state updates. This store has three important methods.\n\nThe first method of this store is called `getState`. It retrieves the current state of the **Redux store**. If we were on this, we're going to see zero because this is the initial state of our application.\n\nThe second and the most commonly used store method is called `dispatch`. It lets you dispatch actions to change the state of your application. If we log this store state after dispatch, we're going to see that it has changed.\n\n![Store Methods](./Images/Methods.png)\n\nOf course, always log into the console gets boring, so we're actually going to render something to the body with the help of the third Redux store method, called `subscribe`. It lets you register a **callback** that the Redux store will call any time an action has been dispatched, so that you can update the UI of your application. It will reflect the current application state.\n``` javascript\nstore.subscribe(() => {\n  document.body.innerText = store.getState();\n});\n\ndocument.addEventListener('click', () => {\n  store.dispatch({ type: 'INCREMENT' });\n});\n```\nI'm being very naive now. I'm not using **React** or anything. I'm just rendering the `counter` into the document body. Any time the body is clicked, I'm going to dispatch an action to increment this `counter`.\n\n![Subscribe Method](./Images/Subscribe.png)\n\nIf you pay close attention, you will notice that the **initial state**, the zero, was not rendered. This is because I'm rendering inside the **subscribe callback**, but it doesn't actually fire the very first time.\n``` javascript\nconst render = () => {\n  document.body.innerText = store.getState();\n};\n\nstore.subscribe(render);\nrender();\n```\nSo I extract this logic into **render method**. I `subscribe` the render method to this **store**. I also call it once to render the **initial state**. Now it renders the zero, and the click increments the counter. This is our first working Redux application.\n","07implementingStoreFromScratch.md":"In the previous video we looked at how to implement a simple counter example using the `createStore` function provided by **Redux** and the store object it returns that provides the `getState` method to get the current application state, the `dispatch` method, to change the current application state by dispatching an action, and the `subscribe` method to subscribe to the changes and re-render our application with the current state of the app.\n\nIf you're like me you prefer to understand the tools that you're using. In this tutorial we're going to re-implement the `createStore` function provided by Redux from scratch. The first and the only form of what we know so far argument to the `createStore` function is the `reducer` function provided by the application.\n\nWe know that the **store** holds the current state. We keep it in a variable, and the `getState` function is going to return the current value of that variable. This function, combined with the `dispatch` function and a `subscribe` function on a single object is what we call the **Redux store**.\n\n``` javascript\nconst createStore = (reducer) => {\n  let state;\n  let listeners = [];\n\n  const getState = () => state;\n\n  const dispatch = (action) => {\n\n  };\n  const subscribe = (listener) => {\n\n  };\n  return { getState, dispatch, subscribe };\n};\n```\n\nBecause the `subscribe` function can be called many times, we need to keep track of all the **changed listeners**. Any time it is called we want to push the **new listener** into the array. Dispatching an action is the only way to change the internal state.\n\n``` javascript\nconst subscribe = (listener) => {\n  listeners.push(listener);\n};\n```\n\nIn order to calculate the new state we call the `reducer` with the current state and the action being dispatched. After the state was updated, we need to notify every changed listener, by calling it.\n\n``` javascript\nconst dispatch = (action) => {\n  state = reducer(state, action);\n  listeners.forEach(listener => listener());\n};\n```\n\nThere is an important missing piece here. We haven't provided a way to **unsubscribe** a listener. Instead of adding a dedicated `unsubscribe` method, we'll just return a function from the `subscribe` method that removes this listener from the listeners' array.\n\n``` javascript\nconst subscribe = (listener) => {\n  listeners.push(listener);\n  return () => {\n    listeners = listeners.filter(l => l !== listener);\n  };\n};\n```\n\nFinally, by the time the store is returned we wanted to have the initial state populated. We're going to `dispatch` a dummy action just to get the reducer to return the initial value.\n\n``` javascript\ndispatch({});\n```\n\nThis implementation of the Redux store apart from a few minor details and edge cases, is the `createStore`  shipped with Redux.\n\n![Finished Store](./Images/FinishedStore.png)e\n","08reactCounterExample.md":"In the simplest counter example, I update the **document body** manually any time this tool state changes. But, of course, this approach does not scale to complex applications. Instead of manually updating the **DOM**, I'm going to use **React**.\n\nI'm adding the script corresponding to **React** and **react-dom** packages and a root `<div/>` to render to. Now I can call the `ReactDOM.render` with my root component. The `render` function is called any time this store state changes, so I can safely pass the current state of this store as a `prop` to my root component.\n\n``` javascript\nconst render = () => {\n  ReactDOM.render(\n    <Counter value={store.getState()} />\n    document.getElementById('root')\n  );\n}\n```\n\nSince this state is held inside the **Redux Store**, the counter component can be a simple function, which is a supported way of declaring components since React 14.\n\n``` javascript\nconst Counter = ({value}) => (\n  <h1>{value}</h1>\n);\n```\n\nI want to add, `DECREMENT`, and `INCREMENT` buttons to the component, but I don't want to hard-code the Redux dependency into the component. So I just add `onIncrement` and `onDecrement` props as **callbacks**. In my `render` method, I pass the callbacks that call `store.dispatch` with appropriate actions. Now the application state is updated when I click the buttons.\n\n``` javascript\nconst Counter = ({\n  value,\n  onIncrement,\n  onDecrement\n}) => (\n  <div>\n  <h1>{value}</h1>\n  <button onClick={onIncrement}>+</button>\n  <button onClick={onDecrement}>-</button>\n  </div>\n);\n\n<Counter\n      value={store.getState()}\n      onIncrement={() =>\n        store.dispatch({\n          type: 'INCREMENT'           \n        })            \n      }\n      onDecrement={() =>\n        store.dispatch({\n          type: 'DECREMENT'           \n        })            \n      }\n    />\n```\n\nLet's recap how this application works. The `counter component` is what I call a **dumb component**. It does not contain any **business logic**. It only specifies how the current application state transforms into renderable output and how the callbacks, passed via props, are bound to the event handlers.\n\n![Counter Example](./Images/CounterExample.png)\n\nWhen we render a counter, we specify that its value should be taken from the **Redux Store** current state. When the user presses `INCREMENT` or `DECREMENT`, we dispatch corresponding action to the **Redux Store**. Our reducer specifies how the next state is calculated based on the current state and the action being dispatched.\n\nFinally, we `subscribe` to the **Redux Store**, so our `render` function runs anytime the state changes, so the counter gets the current state.\n","09avoidingArrayMutations.md":"In this lesson, I use **Expect Library** to make test assertions, and **deepFreeze** to make sure that my code is free of **mutations**.\n\nLet's say that I want to implement a count release application. I would need to write a few functions that operate on its state, and its state is an array of JavaScript numbers representing the individual counters.\n\nThe first function I want to write is called `addCounter`, and all it should do is to append a zero at the end of the past array.\n\n``` javascript\nconst addCounter = (list) => {\n\n};\n\nconst testAddCounter = () => {\n  const listBefore = [];\n  const listAfter = [0];\n  expect(\n    addCounter(listBefore)\n  ).toEqual(listAfter);\n};\n\ntestAddCounter();\nconsole.log('All tests passed');\n```\n\nAt first, I use the array `push` method to add a new item at the end of the array, and it works.\n\n``` javascript\nconst addCounter = (list) => {\n  list.push(0);\n  return list;\n};\n```\n\nHowever, we need to learn to avoid mutations in **Redux**, and I'm enforcing this by calling `deepFreeze` on the original array.\n\n``` javascript\ndeepFreeze(listBefore);\n```\n\nNow my attempt to `push` does not work. It cannot add a new property to a frozen object. Instead of `push`, I'm going to use the `concat` method, which does not modify the original array.\n\n``` javascript\nconst addCounter = (list) => {\n  return list.concat([0]);\n};\n```\n\nNow the tests pass without **mutations**, and I can also use the new ES6 **array spread** operator to write the same code in a more concise way.\n\n``` javascript\nconst addCounter = (list) => {\n  return [...list, 0];\n};\n```\n\nMy next function is called `removeCounter`, and it accepts two arguments, an array of numbers, and the index of the number to skip from the array.\n\n``` javascript\nconst removeCounter = (list, index) => {\n\n};\n\nconst testRemoveCounter = () => {\n  const listBefore = [0, 10, 20];\n  const listAfter = [0, 20];\n\n  expect(\n    removeCounter(listBefore, 1)\n  ).toEqual(listAfter);\n};\n```\n\nIf I've got three numbers and I'm passing one as the second argument, I expect to receive an array with two numbers with the second item skipped in the result array.\n\nUsually, to delete an item from the array, I would use the `splice` method. However, `splice` is a **mutating** method, so you can't use it in Redux.\n\n``` javascript\nconst removeCounter = (list, index) => {\n  list.splice(index, 1);\n  return list;\n};\n```\n\nI'm going to `deepFreeze` the array object, and now I need to figure out a different way to remove an item from the array without mutating it.\n\nI'm using a method called `slice` here, and it doesn't have anything to do with `splice`. It is **not mutating**, and it gives me a part of the array from some beginning to some end index.\n\n``` javascript\nconst removeCounter = (list, index) => {\n  return [\n    ...list.slice(0, index),\n    ...list.slice(index + 1)\n  ];\n};\n```\n\nWhat Im doing is that Im taking the parts before the `index` I want to skip and after the `index` I want to skip, and I concatenate them to get a new array.\n\nFinally, instead of writing it as a method chain with concat calls, I can use the ES6 **array spread** operator to write it more concisely.\n\nNow that we implemented adding and removing counters, let's implement increment in the counter. The `incrementCounter` function takes your arguments, the array and the index of the counter that should be incremented, so the return value has the same count of items, but one of them is incremented.\n\n``` javascript\nconst incrementCounter = (list, index) => {\n\n};\n\nconst testIncrementCounter = () => {\n  const listBefore = [0, 10, 20];\n  const listAfter = [0, 11, 20];\n\n  expect(\n    incrementCounter(listBefore, 1)\n  ).toEqual(listAfter)\n};\n```\n\nDirectly setting the array value at index works, but this is a **mutation**. If we add a `deepFreeze` call, it's not going to work anymore, so how do we replace a single value in the array without mutating it?\n\n``` javascript\nconst incrementCounter = (list, index) => {\n  list[index]++;\n  return list;\n};\n```\n\nIt turns out that the answer is really similar to how we remove an item. We want to take the `slice` before the index, `concat` it with a single item array with a new value, and then `concat` it with the rest of the original array.\n\n``` javascript\nconst incrementCounter = (list, index) => {\n  return [\n    ...list.slice(0,index),\n    list[index] + 1,\n    ...list.slice(index + 1)\n  ];\n};\n```\n\nFinally, with the ES6 **spread operator**, we can spread over the left part of the array, specify the new item, and then spread over the right part of the original array, and this looks much nicer.\n\nIn this lesson, you learned how to use the `concat` method or the **spread operator**, and the `slice` method to add, remove, and change items in arrays without mutating them, and how to protect yourself with **deepFreeze** from mutation in your tests.\n","10avoidingObjectMutations.md":"Like in previous example, I use **expect** and **deepFreeze** libraries from NPM to make my test assertions. This time, I'm testing a function called `toggleTodo` that takes our to-do object and flips its completed field. If completed was `false`, it should be `true` in the **return value**. If it was `true`, it should be `false`.\n\n``` javascript\nconst toggleTodo = (todo) => {\n\n};\n\nconst testToggleTodo = () => {\n  const todoBefore = {\n    id: 0,\n    text: 'Learn Redux',\n    completed: false\n  };\n  const todoAfter = {\n    id: 0,\n    text: 'Learn Redux',\n    completed: true\n  };\n\n  expect(\n    toggleTodo(todoBefore)\n  ).toEqual(todoAfter);\n};\n\ntestToggleTodo();\nconsole.log('All tests passed.');\n```\n\nJust like in the previous lesson, I'm going to start by writing a **mutated** version that passes the current test. A mutated version just **flips** the completed field, reassigns it on the past object.\n\n``` javascript\nconst toggleTodo = (todo) => {\n  todo.completed = !todo.completed;\n  return todo;\n};\n```\n\nWhile it works, we know that **mutations** are not allowed in **Redux**. So to enforce this, I'm calling `deepFreeze` on my to-do object. I'm not allowed to change its completed field anymore.\n\nOne way out of this would be to create the new object with every field copied from the original object except the completed field, which would be flipped. However, if we later add new properties to the new object, we might forget to update this piece of code to include them.\n\n``` javascript\nconst toggleTodo = (todo) => {\n  return Object.assign({}, todo, {\n    completed: !todo.completed\n  });\n};\n```\n\nThis is why I suggest you to use `Object.assign` method, which is new to **ES6**. It lets you assign properties of several objects onto the target object. Note how the object assign argument order corresponds to that of the JavaScript assignment operator.\n\nThe left argument is the one whose properties are going to be assigned, so it's going to be **mutated**. This is why we're passing an empty object as the first argument, so we don't **mutate** any existing data. Every further argument to `Object.assign` will be considered one of the source objects whose properties will be copied to the target object.\n\nIt is important that if several sources specify different values for the same property, the last one wins. This is what we use to override the completed field despite what the original to-do object says.\n\nFinally, you need to remember that `Object.assign` is a new method in **ES6**, so it is not natively available in all the browsers. You should use a **polyfill**, either the one that ships with Babel or a standalone `Object.assign` polyfill, to use it without risking crashing your website.\n\n``` javascript\nconst toggleTodo = (todo) => {\n  return {\n    ...todo,\n    completed: !todo.completed\n  };\n};\n```\n\nAnother option that doesn't require a **polyfill** is to use the new **object spread** operator, which is not part of **ES6**. However, it is proposed for **ES7**. It is fairly popular, and it is enabled in **Babel** if you use the **stage two** preset.\n","11writingATodoListReducerAdding.md":"Just like in the previous two lessons, I'm using **expect** library to make test assertions and **deepFreeze** library to prevent accidental mutations in my code. In this lesson, I will create the **reducer** for a to-do list application whose state is described an array of to-dos.\n\n``` javascript\nconst todos = (state = [], action) => {\n\n};\n```\nJust to remind you what a **reducer** is, it's a **pure function** you write to implement the update logic of your application -- that is, how the next state is calculated given the current state and the action being dispatched.\n\nBefore writing a **reducer**, I want to have a way of knowing whether its code is correct, so I'm starting by writing a test for it. I'm declaring two variables, the state before, which is an empty array, and the action being dispatched, which is an action describing user adding any to-do with some ID and a text.\n\n``` javascript\nconst testAddTodo = () => {\n  const stateBefore = [];\n  const action = {\n    type: 'ADD_TODO',\n    id: 0,\n    text: 'Learn Redux'\n  };\n  const stateAfter = [\n    {\n      id: 0,\n      text: 'Learn Redux',\n      completed: false\n    }\n  ];\n};\n```\n\nI am also declaring the state I expect to get after calling the **reducer**. Like state before, it is an array, but this time, it has a single element representing the to-do that was just added. So it has the same ID and the text as the action object. It also has an additional field called, `completed`, that I want to be initialized to be `false`.\n\n``` javascript\ndeepFreeze(stateBefore);\ndeepFreeze(action);\n```\n\nWe want to make sure that the **reducer** is a pure function, so I'm calling `deepFreeze` both on the `stateBefore` and the `action`. Finally, I am ready to use the expect library to verify that if I call the to-do reducer with the `stateBefore` and the `action` object, I'm going to get the result that is deeply equal to the `stateAfter` I just declared.\n\n``` javascript\nexpect(\n  todos(stateBefore, action)\n).toEqual(stateAfter);\n```\n\nThis concludes my first test. Now I can call it just like a regular JavaScript function. If it doesn't **throw** an the expect call, I'm going to see a message saying that the tests have passed.\n\nOf course, it fails because the **reducer** is not implemented yet. It's an empty function. So it returns `undefined` instead of the array with a single item that I expect in the test.\n\nTo fix this, I would need my **reducer** to take a look at the `action.type` property, which is a string. When it matches the `ADD_TODO` string, which I specify as the `action.type` in my test, to satisfy the test I need to return a new array which includes all items from the original array but also a new to-do item that has its ID and text copied from the action object and a completed field set to `false`.\n\n``` javascript\nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        {\n          id: action.id,\n          text: action.text,\n          completed: false\n        }\n      ];\n      default:\n        return state;\n  }\n};\n```\n\nFinally, I add a default case to my **switch statement** because every **reducer** has to return the current state for any unknown action.\n\nNow the test runs successfully. Let's recap the data flow in this example to see why.\n\nFirst, I create the state array, which is an empty array, and the action object inside my test function. I'm passing them as arguments to my `reducer` function, called, `todos`. The `todos reducer` accepts the state and the action as arguments and takes a look at the `action.type`.\n\nIn this case, the `action.type` is a string saying, `ADD_TODO`, so it matches the switch case inside the reducer. The **reducer** returns a new array which contains the items from the old array and the new item representing the added to-do.\n\nHowever, the state we passed from the test was actually an empty array, so, at the end, we're going to get an array with a single item, which is the new to-do.\n\nFinally, we compare the return value to an array with a single to-do item to make sure that the **reducer** works as intended. The equality check passes. This makes the test successful.\n","12writingATodoListReducerToggling.md":"In this lesson, we will continue creating the **reducer** for to-do list application. The only action that this reducer currently handles is called `Add_TODO`. We also created a test that makes sure that when the `reducer` is called with an empty array as a state and the `Add_TODO` action, it returns an array with a single to do element.\n\nIn this lesson, we will follow the same approach to implement another action called `Toggle_ToDo`. We're going to start with a test again. This time, we're testing a different action and we have a different initial state. The state before calling the `reducer` now includes two different to-dos with ID zero and one. Notice how both of them have their completed fields set to `false`.\n\n``` javascript\nconst testToggleTodo = () => {\n  const stateBefore = [\n    {\n      id: 0,\n      text: 'Learn Redux',\n      completed: false\n    },\n    {\n      id: 1,\n      text: 'Go shopping',\n      completed: false\n    }\n  ];\n};\n```\n\nNext, I declare the `action`. The `action` is an object with the type property which is a toggle to-do string and the ID of the to-do that I want to be toggled. I declare the state that I expect to receive after calling the `reducer`. It's pretty much the same as before calling the `reducer`. However, I expect the to-do with the ID specified in the action or one in this case. The change is completed field.\n\n``` javascript\nconst action = {\n  type: 'TOGGLE_TODO',\n  id: 1\n};\nconst stateAfter = [\n  {\n    id: 0,\n    text: 'Learn Redux',\n    completed: false\n  },\n  {\n    id: 1,\n    text: 'Go shopping',\n    completed: true\n  }\n];\n```\n\nThe reducer must be a **pure function**. As a matter of precaution, I called `deepFreeze` on the state and the action. Finally, just like in the previous lesson, I'm asserting that the result of calling my `reducer` with the state before and the action is going to be **deeply equal** to the state after.\n\n``` javascript\ndeepFreeze(stateBefore);\ndeepFreeze(action);\n\nexpect(\n  todos(stateBefore, action)\n).toEqual(stateAfter);\n```\n\nMy test is a function, so I need to call it at the end of the file. If I run it, it fails because I have not implemented handling this action yet.\n\nI'm adding a new switch case to my **reducer**. I remember that I shouldn't change the original array, so I'm using the **array map** method to produce a new array.\n\nThe function I pass as an argument will be called for every to-do. If it's not a to-do I'm looking for, I don't want to change it. I just return it as is. However, if the to-do is the one we want to toggle, I'm going to return a new object that has all the properties of the original to-do object thanks to the object's **spread operator**, but also an inverted value of the completed field.\n\n\n``` javascript\ncase 'TOGGLE_TODO':\n      return state.map(todo => {\n        if (todo.id !== action.id) {\n          return todo;\n        }\n\n        return {\n          ...todo,\n          completed: !todo.completed\n        };\n```\n\nNow both of our tests run successfully. We have an implementation of the **reducer** that can add and toggle to-dos.\n","13reducerCompositionWithArrays.md":"In the previous lesson we created a **reducer** that can handle two actions, **adding** a new to-do, and **toggling** an existing to-do. Right now, the code to update the to-do item or to create a new one is placed right inside of the **to-dos reducer**.\n\nThis function is hard to understand because it makes us two different concerns, how the to-do's array is updated, and how individual to-dos are updated. This is not a problem unique to **Redux**. Any time a function does too many things, you want to extract other functions from it, and call them so that every function only addresses a single concern.\n\n``` javascript\nconst todo = (state, action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return {\n        id: action.id,\n        text: action.text,\n        completed: false\n      };\n    case 'TOGGLE_TODO':\n      if (state.id !== action.id) {\n        return state;\n      }\n\n      return {\n        ...state,\n        completed: !state.completed\n      };\n    default:\n      return state;\n  }\n};\n```\n\nIn this case, I decided that creating and updating a to-do in response to an action is a separate operation, and needs to be handled by a separate function called `todo`. As a matter of convention, I decided that it should also accept two arguments, the current state and the action being dispatched, and it should return the next state.\n\nBut in this case, this state refers to the individual to-do, and not to the list of to-dos. Finally, there is no magic in **Redux** to make it work. We extracted the `todo reducer` from the `todos reducer`, so now we need to call it for every to-do, and assemble the results into an array.\n\n``` javascript\nswitch (action.type) {\n  case 'ADD_TODO':\n    return {\n      ...state,\n      todo(undefined, action)\n    };\n  case 'TOGGLE_TODO':\n    return stat.map(t => todo(t, action));\n  default:\n    return state;\n}\n```\n\nWhile this is not required in this particular example, I suggest that you always have the **default case** where you return the **current state** to avoid all problems in the future. The pattern described in this lesson is pervasive in Redux's development, and is called **reducer composition**.\n\n``` javascript\n  default:\n    return state;\n```\n\nDifferent reducers specify how different parts of the state tree are updated in response to actions. **Reducers** are also **normal JavaScript functions**, so they can call other reducers to delegate and abstract a way of handling of updates of some parts of this tree they manage.\n\nThis pattern can be applied many times, and while there is still a single **top level reducer** managing the state of your app, you will find it convenient to express it as many reducers call on each other, each contribution to a part of the applications **state tree**.\n","14reducerCompositionWithObjects.md":"In the previous lesson, we established the pattern of **reducer composition** where one reducer can be called by another reducer to update items inside an array.\n\nIf we create a **store** with this **reducer** and log its state, we will find that the initial state of it is an empty array of to-dos. If we dispatch an `ADD_TODO` action, we will find that the corresponding to do has been added to the **state array**.\n\nIf we dispatch another `ADD_TODO` action, the corresponding to do will also be added at the end of the array and dispatch in a `TOGGLE_TODO` action with ID zero will **flag** the completed field of the to do with ID zero.\n\nRepresenting the whole state of the application as an array of to-dos works for a simple example, but what if we want to store more information? For example, we may want to let the user choose which to-dos are currently visible with the `visibilityFilter` such as show completed, `SHOW_ALL`, or `SHOW_ACTIVE`.\n\n``` javascript\nconst visibilityFilter = (\n  state = 'SHOW_ALL',\n  action\n) => {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter;\n    default:\n      return state;\n  }\n};\n```\n\nThe state of the `visibilityFilter` is a simple string representing the current filter. It is changed by `SET_VISIBILITY_FILTER` action.\n\nTo store this new information, I don't need to change the existing reducers. I will use the **reducer composition** pattern and create a new **reducer** that calls the existing reducers to manage parts of its state and combines the results in a **single state object**.\n\n``` javascript\nconst todoApp = (state = {}, action) => {\n  return {\n    todos: todos(\n      state.todos,\n      action\n    ),\n    visibilityFilter: visibilityFilter(\n      state.visibilityFilter,\n      action\n    )\n  }\n}\n```\n\nNow that the first time it runs, it will pass `undefined` as the state of the child reducers because the initial state of the combined reducer is an empty object, so all its fields are `undefined`. This gets the **child reducers** to return their **initial states** and populates the **state object** for the first time.\n\nWhen an `action` comes in, it calls the reducers with the pass of the state that they manage and the action and combines the results into the new **state object**.\n\n``` javascript\nconst store = createStore(todoApp);\n```\n\nThis is another example of the **reducer composition** pattern, but this time we use it to combine several reducers into a single reducer that we will now use to create our **store**. The initial state of the combined reducer now contains the initial states of independent reducers. Any time an action comes in, those reducers handle the action independently.\n\nThis pattern helps scale Redux's development because different people on the team can work on different reducers handling the same actions without running into each other and causing merge conflicts.\n\n![Dispatching visibility Filter](./Images/DispatchingVisibilityFilters.png)\n\nFinally, I'm dispatching the `SET_VISIBILITY_FILTER` action. You can see that it doesn't affect the to-dos, but the `visibilityFilter` field has been updated.\n","15reducerCompositionWithCombineReducers.md":"In the previous lesson we learned how to use the reducer composition pattern to let different **reducers** handle different parts of the state tree, and then combine their results.\n\nThis pattern is so common that it's present in most **Redux** applications. This is why Redux provides a function called `combineReducers` that lets you avoid writing this code by hand. Instead, it generates the top level reducer for you.\n\n``` javascript\nconst { combineReducers } = Redux;\nconst todoApp = combineReducers({\n  todos: todos,\n  visibilityFilter: visibilityFilter\n});\n```\n\nThe **only argument** to combine **reducers** is an object. This object lets me specify the mapping between the state field names, and the **reducers** managing them. The return value of the `combineReducer` is called a **Reducer function**, which is pretty much equivalent to the reducer function I wrote by hand previously.\n\nThe keys of the object I configure combined **reducers** with correspond to the fields that the state object is going to manage. The values of the object I have asked to `combineReducer`, are the producers we should call to update the correspondence state fields.\n\nThis `combineReducer` call says that the to-do's field inside the state object managers will be updated by the reduce-reducer, and the `visibilityFilter` field inside the state object will be updated by calling the `visibilityFilter` reducer. The results will be assembled into a single object. In other words, it behaves pretty much exactly as the function commented down below.\n\nFinally, I will establish a useful convention. I will always name my **reducers** after the **state keys** they manage. Since the key names and the value names are now the same, I can omit the values thanks to the ES6 object literal shorthand notation.\n\n``` javascript\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n});\n```\n\nIn this lesson, you learned how to generate a simple reducer that calls many **reducers** to manage parts of its tree by using the `combineReducers` utility function.\n","16implementingCombineReducersFromScratch.md":"In the previous lesson, we learned to use the `combineReducers` function, which comes with **Redux** and generates one reducer from several other **reducers**, delegating to them paths of the state tree.\n\nTo gain a deeper understanding of how exactly `combineReducers` works, we will implement it from scratch in this lesson.\n\n`combineReducers` is a function, so I'm writing a function declaration. Its **only argument** is the mapping between the **state keys** and the **reducers**, so I'm just going to call it `Reducers`.\n\n``` javascript\nconst combineReducers = (reducers) => {\n\n};\n```\n\n\nThe return value is supposed to be a reducer itself, so this is a function that returns another function. The signature of the return function is a reducer signature. It has the state and the action.\n\n``` javascript\nconst combineReducers = (reducers) => {\n  return (state = {}, action) => {\n\n  };\n};\n```\n\nNow, I'm calling the object key's method, which gives me all the keys of the reducer's object. In our example, this is todos and the `visibilityFilter`.\n\nNext, I'm calling the `reduce` method on the keys, because I want to produce a single value, such as the next state, by accumulating over every reducer key and calling the corresponding reducer.\n\n``` javascript\nreturn (state = {}, action) => {\n  return Object.keys(reducers).reduce(\n\n      );\n      return nextState;\n    }\n  );\n};\n```\n\nEach reducer passed through the `combineReducers` function is only responsible for updating a part of the state. This is why I'm saying that the next state by the given key can be calculated by calling the corresponding reducer by the given key with the current state by the given key and the action.\n\n``` javascript\nreturn Object.keys(reducers).reduce(\n  (nextState, key) => {\n    nextState[key] = reducers[key](\n      state[key],\n      action\n    );\n    return nextState;\n  },\n  {}\n);\n```\n\nThe array reduce wants me to return the next accumulated value from the call back, so I'm returning the next state. I'm also specifying an empty object as the initial next state, before all the keys are processed.\n\nThere we have it. This is a working reimplementation of `combinedReducers` utility from **Redux**.\nLet's briefly recap how it works. I'm calling `combinedReducers` with an object whose values are the reducer functions and keys are the state field they manage.\n\n```javascript\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n});\n```\n\nInside the generated reducer, I'm retrieving all the keys of the **reducers** I passed to combine **reducers**, which is an array of strings, `todos` and `visibilityFilter`.\n\nI'm starting with an empty object for my next state and I'm using the reduce operation of these keys to fill it gradually.\n\nNotice that I'm mutating the next state object on every iteration. This is not a problem, because it is the object I created inside the reducer. It is not something passed from outside, so reducer stays a pure function.\n\n```javascript \n(nextState, key) => {\n    nextState[key] = reducers[key](\n      state[key],\n      action\n    );\n    return nextState;\n  },\n```\n\nTo calculate the next state for a given key, it calls the corresponding reducer function, such as `todos` or `visibilityFilter`.\n\nThe generated reducer will pass through the child reducer only if part of its state by the key. If its state is a single object, it's only going to pass the relevant part, such as `todos` or `visibilityFilter`, depending on the current key, and save the result in the next state by the same key.\n\nFinally, we use the array reduce operation with the empty object as the initial next state, that is being filled on every iteration until it is the return value of the whole reduce operation.\n\nIn this lesson, you learned how to implement the combined **reducers** utility that comes with **Redux** from scratch.\n\nIt is not essential to use in **Redux**, so it is fine if you don't fully understand how it works yet. However, it is a good idea to practice functional programming and understand functions can take other functions as arguments and return other functions, because knowing this will help you get more productive in **Redux** in the long term.\n","17reactTodoListExampleAdding.md":"In the previous lessons, we learned how to split the root registers into many smaller registers that manage parts of the stream tree.\n\nWe have a ready ToDo app **reducer** that handles all the actions of our simple ToDo application. Now it's trying to implement the View layer. I'm going to use **React** in this example.\n\nI'm adding **react** and **react-dom** packages from the Facebook CDN. I'm also adding a div with the ID root, which is where I'm going to **render** my react application.\n\n### javascript\n``` javascript\nconst render = () => {\n\n};\n\nstore.subscribe(render);\nrender();\n```\n\n### html\n```html\n<body>\n  <div id='root'></div>\n</body>\n```\n\nSimilar to the react counter-example from the eighth lesson, I declare a **render function** that is going to update dom in response to the current application state. I'm going to subscribe to these core changes and call render whenever the store changes and wants to render the initial state.\n\nThe implementation of the render method is going to use react, so it's called `ReactDOM.render` for some to-do app component I haven't written yet. It renders it into the div I created inside the HTML. It's div with the ID called \"root\".\n\n``` javascript\nconst render = () => {\n  ReactDOM.render(\n    <TodoApp />,\n    document.getElementById('root')\n  );\n};\n\n```\n**React** provides a base class for all components. I'm grabbing from the react object called **reactComponent**. I'm declaring my own `ToDoApp` component that extends the react-based component. This component is only going to have a render function and is going to return a `div`. Inside the div, I'm going to place a button saying add todo them.\n\n``` javascript\nconst { Component } = React;\n\nlet nextTodoId = 0;\nclass TodoApp extends Component {\n  render() {\n    return (\n      <div>\n        <button onClick={() => {\n          store.dispatch({\n            type: 'ADD_TODO',\n            text: 'Test',\n            id: nextTodoId++\n          });\n        }}>\n          Add Todo\n        </button>\n      </div>\n    );\n  }\n}\n```\n\nI don't want to add an input field yet to keep the example simple at first. I'm dispatching the out ToDo action, and I'm going to put a test as my checks for the action. It's going to keep adding to this with the products test.\n\nThe ID, I need to specify a sequential ID. This is why I'm declaring an global variable called `NextToID`, and I'm going to keep in command in it. Every time, it's going to emit a new id.\n\nI also want to display a list of the ToDo list. Assuming that I have the ToDos inject as ToDos prop, I'll call map and for every ToDo item, I'm going to show a list item show in the text of that particular ToDo.\n\n``` javascript\n<ul>\n  {this.props.todos.map(todo =>\n    <li key={todo.id}>\n      {todo.text}\n    </li>\n   )}\n</ul>\n```\n\nFinally, because I need to the ToDo as a prop, I'm going to pass it to the `TodoApp` by reading the currents chores straight and written its ToDo field.\n\n``` javascript\n  <TodoApp todos={store.getState().todos} />\n```\n\n![Adding Todos](./Images/AddTodos.png)\n\nYou can see that there is a button at ToDo and anytime I press it, I see a new ToDo with a test text. I'm going to add an input inside my render function, and I'm using the react callback ref API where ref is a function, it gets the note corresponding to the ref, and I'm saving that note with some name. In this case, this.input.\n\n``` javascript\n<input ref={node => {\n  this.input = node;\n}}\n\n<button onClick={() => {\n  store.dispatch({\n    type: 'ADD_TODO',\n    text: this.input.value,\n    id: nextTodoId++\n  });\n  this.input.value = '';\n}}>\n```\n\nI'm able to read the value of the input inside my event handler. I'm reading this job input that value. I'm also able to reserve the value after dispatching the action so that the field is cleared. If I try write something to build and press AddtoDo, the AddtoDo action is dispatched and the field is cleared.\n\n![Adding Todos with this.input](./Images/AddTodoThisInput.png)\n\nLet's take a moment to recap how this application works. It starts with a `ToDoApp` **react component**. This component is not aware of how exactly ToDos are being added. However, it can express its desire to mutate the state by dispatching an action with the type ToDo.\n\n```javascript\n<button onClick={() => {\n  store.dispatch({\n    type: 'ADD_TODO',\n    text: this.input.value,\n    id: nextTodoId++\n  });\n  this.input.value = '';\n}}>\n```\n\nFor the text field, it uses the current input value and it passes an incrementing ID as the ID of ToDo. Every ToDo needs its own ID, and in this approach, we're just going to increment the counter, so it always gives us the next integer as ID.\n\nIt is common for **react components** to dispatch actions in **Redux apps**. However, it is equally important to be able to render the current state. My `ToDoApp` component assumes that it's going to receive ToDos as a prop, and it maps over the ToDo list to display a list of them using the ID as a key.\n\n```html\n<ul>\n  {this.props.todos.map(todo =>\n    <li key={todo.id}>\n      {todo.text}\n    </li>\n  )}\n</ul>\n```\n\nThis component is being rendered in the render function that runs any [indecipherable 4:53] changes and initially. The render function reads the current state of this chore and passes the ToDos array that it gets from the current state of this chore to do to the app component as a prop.\n\n```javascript\nconst render = () => {\n  ReactDOM.render(\n    <TodoApp\n      todos={store.getState().todos}\n    />,\n    document.getElementById('root')\n  );\n};\n```\n\nThe render function is called on every store change so the ToDos prop is always up to date. This was the rendering part of the **redux** flow. Let's recap how mutations work in Redux.\n\nAny state change is caused by a store dispatch call somewhere in the component. When an action is dispatched, this store calls the **reducer** it was created with, with the current state and the action being dispatched.\n\nIn our case, this is the `TodoApp` reducer, which we obtained by combining `visibilityFilter` and the `todos` reducer.\n\nIt matches the action type and the `switch` statement. If the action type is `ADD_TODO` and indeed, it is equal to add ToDo string. In this case, it will call the child `todo` reducer, passing it `undefined`, because this is no state for a new ToDo that it can pass in the action.\n\n```javascript \ncase 'ADD_TODO':\n  return [\n    ...state,\n    todo(undefined, action)\n  ];\n```\n\nWe have a similar state statement inside the ToDo reducer and the action type is add to-do. It returns the initial state of the to-do where the ID and text from the action and the completed field set to false.\n\n```javascript \ncase 'ADD_TODO':\n  return {\n    id: action.id,\n    text: action.text,\n    completed: false\n  };\n```\n\nThe ToDos reducer that called it was returned a new array with all existent items and the new item added at the very end. It adds a need to do to the current state.\n\nFinally, the combined producer called ToDo app will use this new array as the new value for the to-dos field in the global state object. It's going to return a new state object where the ToDos field corresponds to the array with the newly-added ToDo item.\n\n```javascript\nconst todoApp = combineReducers({\n  todos,\n  visibilityFilter\n});\n```\n\nThe `todoApp` reducer is the root reducer in this application. It is the one the straw was created with. Its next state is a next state of the **Redux chore**, and all the listeners are notified.\n\nThe render function is subscribed to the straw changes so it is called again, and it gets the fresh state by call and gets state and it passes the fresh ToDos to the component, re-rendering it with the new [indecipherable 7:24] .\n","18reactTodoListExampleToggling.md":"In the last lesson, we implemented a simple UI for the todo list application that is able to add new todos and view the existing todos in the list.\n\nTo add the todos, we dispatched the `ADD_TODO` action. In this lesson, we're going to dispatch the `TOGGLE_TODO` action to toggle the completed state of the todos by clicking on them.\n\nI'm scrolling down to my **React component**. I've got a list item here corresponding to the todo, so I'm adding the on click handler. When the user clicks on the list item, I want to dispatch an action to my store with a type `TOGGLE_TODO` and the `ID` of the todo being toggled, which I get from the todo object.\n\nThe event handler knows which todo it corresponds to, so it is able to pass its `ID` in the action.\n\n``` javascript \n<ul>\n  {this.props.todos.map(todo =>\n    <li key={todo.id}\n        onClick={() => {\n          store.dispatch({\n            type: 'TOGGLE_TODO',\n            id: todo.id\n          });         \n        }}\n      {todo.text}\n    </li>\n  )}\n</ul>\n```\n\nIn the user interface, I want the completed todos to appear crossed out, so I'm adding this trial attribute to the list item. I'm going to use the text decoration property, which is going to be a line through when todo completed is `true`, and non when todo completed is `false`, so I get a normal looking todo.\n\n``` javascript\nstyle={{\n  textDecoration:\n    todo.completed ?\n      'line-through' : 'none'\n}}>\n```\n\nNow, if I add a couple of todos, I can click on them and they're going to appear toggled, and I can toggle them back. Isn't that satisfying?\n\n![Toggling Todos](./Images/ToggledTodos.png)\n\nLet's recap how toggling the todo actually works.\n\nIt starts with me dispatching the `TOGGLE_TODO` action inside my click handler, with a type `TOGGLE_TODO` and the `ID`, which is the `ID` of the todo being rendered.\n\n```javascript\nonClick={() => {\n  store.dispatch({\n    type: 'TOGGLE_TODO',\n    id: todo.id\n  });         \n}}\n``` \n\nI get the todo object as an argument to the array map call back inside my render method where I render all the todos.\n\nWhen an action is dispatched, the store will call the **root reducer**, which will call the todos reducer with the array of todos and the action. In this case, the action type is `TOGGLE_TODO`, so the todos reducer delegates handling of every todo to the todo reducer with a map function to call it for every todo item. The todo reducer receives the todo as state, and the action.\n\n```javascript \nconst todos = (state = [], action) => {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return [\n        ...state,\n        todo(undefined, action)\n      ];\n    case 'TOGGLE_TODO':\n      return state.map(t =>\n        todo(t, action)\n      );\n    default:\n      return state;\n  }\n};\n```\n\nAgain, we switch on the action type, and it matches `TOGGLE_TODO` string. Now, for every todo whose `ID` does not match the `ID` specified in the action, we just return the previous state, that is the todo object, as it was.\n\nHowever, if the `ID` of the todo matches the one specified in the action, we're going to return any object with all the properties of the original todo, but with the completed field equal to the opposite value of what it was.\n\nThe updated todo item will be included in the todos field under the new application state. Because we subscribe, the render function is going to get the next state of the application in store -- get state -- and pass the new version of the todos to the todo app component, which is going to render the updated todos.\n\nFinally, this trial of the list item, the bands on the todo completed field, which we just updated, which is why it re-renders in a cross-child state.\n","19reactTodoListExampleFiltering.md":"In the previous two lessons, we were working on creating the user interface for the to-do list application that displays the to-dos, lets us add new to-dos, and toggle them on click. We implemented that by dispatching add to-do and toggle to-do actions that we already know how to handle in our reducers.\n\nIn this lesson, we're going to dispatch set `visibilityFilter` reaction and use the `visibilityFilter` field to only show the to-dos the user wants to see -- either the completed to-dos, active to-dos, or all to-dos in the current state.\n\n``` javascript\nconst FilterLink = ({\n  filter,\n  children\n}) => {\n  return (\n    <a href='#'\n       onClick={e => {\n\n       }}\n    >\n      {children}\n    </a>\n  );\n};\n```\n\nI'm starting by creating a new functional component called, `FilterLink` that the user needs to click to switch the current visible to-dos. The `FilterLink` accepts the `filter` prop, which is just a string, and the children, which is the contents of the link. It's going to be a simple A tag that doesn't really link anywhere. It's going to prevent the navigation when clicked.\n\n``` javascript\ne.preventDefault();\nstore.dispatch({\n  type: 'SET_VISIBILITY_FILTER',\n  filter\n});\n```\n\nIt's going to dispatch an action, the type, `SET_VISIBILITY_FILTER`, and pass in the filter prop so that the reducer knows which filter is being clicked. I will pass the children down to the A tag, so the consumer can specify the text of the link. Now I can use it in my to-do app component.\n\nJust below the to-do list, I am adding a paragraph where I'm going to offer the user the choice as to which to-dos should be currently visible by using the filter link component I just created.\n\nThe `filter` prop is one of the three possible values, such as show all, which corresponds to showing every to-do in the state, show active, which means just show the to-dos that are not completed yet, and show completed, which means show the completed to-dos. I'm copy-pasting the filter link, and I'm changing the labels and the filters corresponding to it.\n\n``` javascript\n<p>\n  Show:\n  {' '}\n  <FilterLink\n    filter='SHOW_ALL'\n  >\n    ALL\n  </FilterLink>\n  {' '}\n  <FilterLink\n    filter='SHOW_ACTIVE'\n  >\n    Active\n  </FilterLink>\n  {' '}\n  <FilterLink\n    filter='SHOW_COMPLETED'\n  >\n    Completed\n  </FilterLink>\n</p>\n```\n\nRunning this code will give me three different things under the list of to-dos. Clicking on them will change the state visibility filter field. However, it doesn't have any effect yet because we don't interpret the value of the `visibilityFilter`.\n\nI am creating a new function that is going to help me filter the to-dos according to the filter value. It's called, \"get visible to-dos.\" It accepts two arguments, the to-dos and the filter. It switches on the current filter value.\n\n``` javascript\nconst getVisibleTodos = (\n  todos,\n  filter\n) => {\n  switch (filter) {\n    case 'SHOW_ALL':\n      return todos;\n    case 'SHOW_COMPLETED':\n      return todos.filter(\n        t => t.completed\n      );\n    case 'SHOW_ACTIVE':\n      return todos.filter(\n        t => !t.completed\n      );\n  }\n}\n```\n\nIf the filter is show all, it's going to return all of the to-dos. But if the filter is show completed, it's going to call `todos.filter`, that is array filter method, to only return those to-dos that have completed set to true. Show active is going to the opposite of that. It's going to return only those to-dos where a completed field is false.\n\nNow I need to call this function to filter the to-dos before rendering them. In the **render function** of the `TodoApp` component, I get the visible to-dos by calling `getVisibleTodos` with the to-dos and the visibility filter values from my props. I'm going to use the visible to-dos instead of these props to-dos when I enumerate them for rendering.\n\n``` javascript\nconst visibleTodos = getVisibleTodos(\n  this.props.todos,\n  this.props.visibilityFilter\n);\n```\n\nFinally, I now use the visibility filter inside my `TodoApp` component, so I need to pass it as a prop.\n\nI could do this explicitly, but actually it's easier for me just to spread over all the **state fields**. So every state field inside the state object is passed as a prop to the `TodoApp` component. This way, it receives the `visibilityFilter`. If I add some to-do items and then click on them, so I change their completed fields, and then click on the `visibilityFilter` links, the currently visible to-dos are rendered according to the chosen `visibilityFilter`.\n\n``` javascript\n<TodoApp\n  {...store.getState()}\n/>\n```\n\n![Filters Applied](./Images/FiltersApplied.png)\n\nThe links look all the same right now, but we want to highlight the chosen one. To implement this, we're going to need the `visibilityFilter` prop which says which is the current one.\n\nI'm changing the beginning of the render method to destructure the to-dos and the `visibilityFilter` from the props, so I can access them directly now without typing this .props every time. I'm going to pass the `visibilityFilter` to every filter link, so it can know which filter is the current one and apply different styling if the current filter matches the filter links' own filter.\n\n``` javascript\nconst {\n  todos,\n  visibilityFilter\n} = this.props;\nconst visibleTodos = getVisibleTodos(\n  todos,\n  visibilityFilter\n);\n\n<FilterLink\n  filter='SHOW_ALL'\n  currentFilter={visibilityFilter}\n>\n```\n\nAfter passing the current filter prop to every filter link, I go back to the filter link declaration. I'm adding current filter as a prop to it, and I'm adding a condition that says that when the filter is the current filter, that is, when the link is active, I want to return a span instead of a link because I don't want it to be clickable. I want it to be static text.\n\n``` javascript\nif (filter === currentFilter) {\n  return <span>{children}</span>;\n}\n```\n\nThis completes the user interface of our to-do list example. It lets us add items. It lets us view items, toggle them as completed. When we switch the `visibilityFilter`, it displays only relevant to-dos, and it also updates the link appearance, so we see which link is active.\n\n![Updated Link Appearance](./Images/UpdatedLinkAppearance.png)\n\nLet's recap how a change in the `visibilityFilter` works. It starts with a dispatch code with an action of the type set `visibilityFilter`. It passes filter, which is a prop, to the link component, so every one of those three links is going to have a different filter prop it passes in the action.\n\nThe store dispatch function will call our root reducer with the state and the action which in turn will call the visibility filter reducer with the part of the state and the action.\n\nNote that when the action type is set `visibilityFilter`, it doesn't care for the previous state, it just returns the action filter as the next value, the next state, of the `visibilityFilter` reducer.\n\n```javascript \nconst visibilityFilter = (\n  state = 'SHOW_ALL',\n  action\n) => {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter;\n    default:\n      return state;\n  }\n};\n```\n\nThe **root reducer** will use this new field as part of its new state object.\n\nBecause the `render` function is subscribed to the stored changes, it's going to get this new state object and pass all its keys as props to the `TodoApp` component.\n\n```javascript\nconst render = () => {\n  ReactDOM.render(\n    <TodoApp\n      {...store.getState()}\n    />,\n    document.getElementById('root')\n  );\n}; \n```\n\nThe `TodoApp` component will receive the to-dos and the updated `visibilityFilter` as its props.\n\nBoth these props are passed through the `getVisibleTodos` function, which calculates the currently visible to-dos according to a list of all to-dos and the `visibilityFilter`.\n\n```javascript\nconst visibleTodos = getVisibleTodos(\n  todos,\n  visibilityFilter\n);\n```\n\nThe filter is just a string saying show all, completed, or active.\n\nThe return value is a new array of to-dos that in some cases, filters them and, in some cases, returns as is. The show completed and show active are only different in their predicates.\n\n```javascript \ncase 'SHOW_ALL':\n  return todos;\ncase 'SHOW_COMPLETED':\n  return todos.filter(\n    t => t.completed\n  );\ncase 'SHOW_ACTIVE':\n  return todos.filter(\n    t => !t.completed\n  );\n```\n\nThe return value is the array of visible to-dos. It is used in the `render` function to actually enumerate every to-do and render it.\n\nThe `visibilityFilter` field is also used by the filter links as the current filter because the filter link wants to know whether its filter is the current one in order to render a span instead of a link. This is how clicking a link makes it appear selected and changes the currently displayed items in the list.\n","20extractingPresentationalComponentsTodoTodolist.md":"In the last few lessons, we created user interface for a simple **React** and **Redux** to-do list where I can add items, toggle them as completed, and change the currently visible to-dos.\n\nWe do that by having a single `TodoApp` component that has the input, the button for adding to-dos, the list of currently visible to-dos with click handler. It has these three links that let us change the currently visible to-dos.\n\nThe single component approach worked so far. However, we really want to have many components that can be used, tested, and changed by different people separately. So we're going to **refactor our application** in this lesson.\n\nThe first component I want to extract from the `TodoApp` component is the to-do component that renders a single list item. I am declaring the to-do component as a function which React 14 allows me to do. I'm not sure which props it's going to have, so I'll leave them blank for now. I will just paste the list item I covered before.\n\n``` javascript\nconst Todo = ({\n\n}) => (\n  key={todo.id}\n  <li\n    onClick={() => {\n      store.dispatch({\n        type: 'TOGGLE_TODO',\n        id: todo.id\n      });\n    }}\n    style={{\n      textDecoration:\n        completed ?\n          'line-through' :\n          'none'\n    }}\n  >\n    {todo.text}\n  </li>\n);\n\n```\n\nThe first thing I'm doing is removing the special key property because it's only needed when I enumerate an array. I'll use it later when enumerating many to-dos.\n\nOne of my goals with this refactoring is to make every component as flexible as it is reasonable. Right now, I have hardcoded that clicking a to-do always causes the toggle to-do action. **This is perfectly fine to do in your app.**\n\n*However*, I prefer to have a bunch of components that don't specify any behaviors, and that are only concerned with how things look or how they render. I call such components the **presentational components**.\n\nI would like to give to-do a presentational component, so I removed the on click handler. I promote it to be a prop so that anyone who uses to-do component can specify what happens on the click. You don't have to-do this in your Redux apps, but I find it to be a very convenient pattern.\n\n``` javascript\n<li\n  onClick={onClick}\n  style={{\n    textDecoration:\n      completed ?\n        'line-through' :\n        'none'\n  }}\n>\n  {todo.text}\n</li>\n```\n\nFinally, while it doesn't have a lot of difference, I prefer to keep it explicit what is the data that the component needs to render. Instead of passing a to-do object, I pass completed and text fields as separate props.\n\n``` javascript\nconst Todo = ({\n  onClick,\n  completed,\n  text\n}) => (\n  <li\n    onClick={onClick}\n    style={{...}}\n  >\n    {text}\n  </li>\n);\n```\n\nNote how the to-do component is now a purely presentational component and doesn't specify any behavior. But it knows how to render `AddTodo`.\n\nThe next component I create is called to-do list. It's also a presentational component. It's only concerned with how things look.\n\nIt accepts an array of to-dos. It's going to render an unordered list of them by calling the to-dos map function and rendering at to-do component for every to-do. It tells React to use to-do ID as the unique key for the elements. It spreads over the to-do object properties so the text and completed end up as props on the to-do component.\n\nI need to specify what happens when a to-do is clicked. I could have dispatched an action here. Again, that would be fine, but I want it to be a presentational component, so I'm going to call another function, called on to-do click, and pass the ID of the to-do, and let it decide what should happen. On to-do click is another prop for the to-do list.\n\n``` javascript\nconst TodoList = ({\n  todos\n  onTodoClick\n}) => (\n  <ul>\n    {todos.map(todo =>\n      <Todo\n        key={todo.id}\n        {...todo}\n        onClick{() => onTodoClick(todo.id)}\n       />\n    )}\n   </ul>\n);\n```\n\nBoth to-do and to-do list are presentational components, so we need something I call, **container components** to actually pass the data from this chore and to specify the behavior. In this case, the top level to-do app component acts as a container component. We will see more examples of container components in the future lessons.\n\nIn this case, it just renders the to-do list with visible to-dos as the to-dos, and with a callback that says that when on to-do click is called with a to-do ID, we should dispatch an action on the chore with the type toggle to-do and the ID of the to-do.\n\n``` javascript\n<TodoList\n  todos={visibleTodos}\n  onTodoClick={id =>\n    store.dispatch ({\n      type: 'TOGGLE_TODO',\n      id\n    })\n  } />\n```\n\nLet's recap again how this works. The do to app component renders a to-do list, and it passes a function to it that can dispatch an action. The to-do list component renders the to-do component and passes on click prop which calls on to-do click.\n\nThe to-do component just uses the on click prop it receives and binds it to the list item on click. This way, when it's called, the on to-do click is called, and this dispatches the action and updates the visible to-dos because the action updates the store.\n\n","21extractingPresentationalComponentsAddTodoFooterFilterLink.md":"In the previous lesson, I extracted the `Todo` and `TodoList` components from the `TodoApp` component. In this lesson, I will continue extracting other **presentational components** to separate the looks from the behavior.\n\nNow I want to extract the input and the button into a separate component called, `AddTodo` I'm declaring `AddTodo` as a functional component that doesn't accept any props. I'm going to return these copy pasted input in button, but I'm wrapping them in a div because a component needs to have a single root element.\n\n``` javascript\nconst AddTodo = () => {\n  return (\n    <div>\n      <input ref={node => {\n        this.input = node;\n      }} />\n      <button onClick={() => {\n        store.dispatch({\n          type: 'ADD_TODO',\n          text: this.input.value,\n          id: nextTodoId++\n        });\n        this.input.value = '';\n      }}>\n      Add Todo\n      </button>\n    </div>\n  );\n};\n```\n\nThe functional components don't have instances. However, instead of using this, I can use a local variable called, \"input,\" that I'm going to close over so I can write to it in the callback ref and I can read from it in the event handler.\n\nLike previously, I want it to be a **presentational component** and not specify behavior, so I just called the function called, `onAddClick` passing the current input value. I make on at click a prop so that the component that uses `AddTodo` can specify what happens when that button is clicked.\n\n``` javascript\nconst AddTodo = ({\n  onAddClick\n}) => {\n  let input;\n\n  return (\n    <div>\n      <input ref={node => {\n        input = node;\n      }} />\n      <button onClick={() => {\n        onAddClick(input.value);\n        input.value = '';\n      }}>\n      Add Todo\n      </button>\n    </div>\n  );\n};\n```\n\nAgain, the `TodoApp` component acts as a **container component** for the `AddTodo`. It specifies that when add button is clicked, we should dispatch an action with the type at to-do, the corresponding text, and the next to-do ID.\n\n``` javascript\n<AddTodo\n  onAddClick={id =>\n    store.dispatch({\n      type: 'TOGGLE_TODO',\n      id\n    })\n  } />\n```\n\nThe last component I want to extract today is the footer, which contains all these three filter links. I'm creating a new functional component called, `Footer`. I'm not sure which props it needs, so I skip them. I paste the markup. It seems that the filter link need the visibility filter, so I add it as a prop.\n\nI would like the footer and the filter link to be **presentational components**. However, the filter link includes a short dispatch call. I am replacing it with an on click call. I pass the filter as the single parameter for the calling component's convenience. I add on click to the props.\n\n``` javascript\nconst FilterLink = ({\n  filter,\n  currentFilter,\n  children\n}) => {\n  return (\n    <a href='#'\n      onClick={e => {\n        e.preventDefault();\n        onClick(filter);\n      }}\n     >\n      {children}\n     </a>\n  );\n};\n\nconst Footer = ({\n  visibilityFilter,\n  onFilterClick\n}) => (\n  <p>\n    Show:\n    {' '}\n    <FilterLink\n      filter='SHOW_ALL'\n      currentFilter={visibilityFilter}\n      onClick={onFilterClick}\n    >\n      All\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_ACTIVE'\n      currentFilter={visibilityFilter}\n      onClick={onFilterClick}\n    >\n      Active\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_COMPLETED'\n      currentFilter={visibilityFilter}\n      onClick={onFilterClick}\n    >\n      Completed\n    </FilterLink>\n  </p>\n);\n\n```\nNow I need to specify it every time filter link is used. I add on filter click to the footer. I pass on click equals on filter click for every filter link in the footer, so whatever we pass to the footer as on filter click prop is going to end up in the filter link as on click.\n\nNow I can use the footer component I just defined inside my to-do app component. I need to pass to props, one of them is the visibility filter so it can highlight the active link. Another prop is on filter click where I say that whenever a filter is clicked, I want to dispatch an action with a type set visibility filter and the filter being clicked.\n\n``` javascript\n<Footer\n  visibilityFilter={visibilityFilter}\n  onFilterClick={filter =>\n    store.dispatch({\n      type: 'SET_VISIBILITY_FILTER',\n      filter\n    })\n  }\n/>\n```\n\nFinally, I just noticed that the to-do app component doesn't actually have to be a class. I can turn it into a function. I prefer to-do that when possible.\n\nInstead of destructuring the props inside the render method, I am now doing it inside the argument. I can remove now the destructuring. I'm also going to remove the render method declaration. The visible to-dos are only used in a single place, so I'm moving the get visible to-dos call to the to-do list to-dos prop declaration. Now the body of my function is just a single expression, so I can get rid of the return statement and unintended code to make it look nicer.\n\n``` javascript\nconst TodoApp = ({\n  todos,\n  visibilityFilter\n}) => (\n  <div>\n    <AddTodo ... />\n    <TodoList\n      todos={\n        getVisibleTodos(\n          todos,\n          visibilityFilter\n        )\n      }\n      onTodoClick={ ... }\n    />\n    <Footer ... />\n  </div>\n);\n```\n\nThis concludes the initial refactoring of the to-do list application into a single **container component** called to-do app and many **presentational components** that are only concerned with how things look.\n\n<a class=\"jsbin-embed\" href=\"https://jsbin.com/qaziru/3/embed?js,console\">JS Bin on jsbin.com</a><script src=\"https://static.jsbin.com/js/embed.min.js?3.35.12\"></script>\n\nLet's recap the data flow in this example.\n\nWe have a single **container component** called `TodoApp`. We re-render it any time the store changes. It receives the keys of the global state object as the props, so it receives the to-dos and the visibility filter values.\n\nThe first component it renders is called at to-do.\n\n```javascript \n<AddTodo\n  onAddClick={text =>\n    store.dispatch({\n      type: 'ADD_TODO',\n      id: nextTodoId++,\n      text\n    })\n  }\n/>\n```\n\nAt to-do is a **presentational component** that renders an input and a button. When the button is clicked, it passes the current input value to the `onAddClick` function.\n\n`onAddClick` function is a prop for the `AddTodo` component. In this case, it is specified by the `TodoApp`, which says that when the button is clicked, it should dispatch an action containing the current text in the action object. Dispatching the `AddTodo` action will call our reducer, update this chore state with the new to-dos, and re-render the `TodoApp` component with the new to-dos.\n\nThe to-dos themselves are rendered by the to-do list **presentational component** that receives two props, the currently visible to-dos and the on to-do click callback.\n\nThe `TodoList` component receives an array of to-dos, and it maps over them, rendering individual to-do components. It uses the spread operator to pass every property of the to-do object as a prop to to-do component. It specifies the on click handler as calling on to-do click with the ID of the particular to-do.\n\n```javascript\nconst TodoList = ({\n  todos,\n  onTodoClick\n}) => (\n  <ul>\n    {todos.map(todo =>\n      <Todo\n        key={todo.id}\n        {...todo}\n        onClick={() => onTodoClick(todo.id)}\n      />\n    )}\n  </ul>\n);\n```\n\nThe `Todo` component is defined above. It is also a **presentational component**, so it doesn't specify the behavior. It says that when a list item is clicked, it should call the on click handler. Being a **presentational component**, it specifies how the component looks in different circumstances. In this case, it uses the completed prop to choose between two different styles of the to-do item.\n\n```javascript\n<li\nonClick={onClick}\nstyle={{\n  textDecoration:\n    completed ?\n      'line-through' :\n      'none'\n}}\n>\n```\n\nThe `TodoList` is also **presentational component**. It delegates actually handling the click to `onTodoClick` prop. It passes the ID of the to-do being clicked.\n\nFinally, the `TodoApp` component reacts to it by dispatching an action containing the ID of the to-do clicked and the type toggle to-do.\n\n```javascript\nonTodoClick={id =>\nstore.dispatch({\n  type: 'TOGGLE_TODO',\n  id\n})\n}\n```\n\nThe store will call our reducer and update the state of the application, re-rendering the `TodoApp` component with the new to-dos.\n\nThe footer component receives the current visibility filter as a prop and also receives the on filter click callback that sets the current visibility filter. The footer component renders three filter links, passing down their respective filter values, the on click handler, and the current visibility filter.\n\nThe filter link component being a **presentational component** doesn't know what to-do when it's clicked, so it calls the `onClick` callback, passing the filter, which is different for each of those links, as an argument. The footer delegates handling the click of the `FilterLink` to its own prop, called `onFilterClick`.\n\nFinally, the `TodoApp` component being the **container component** in our application specifies the behavior, which in this case means that when the filter link is clicked, it should dispatch an action with the type set visibility filter, and the new filter.\n\nSeparation of the **presentational components** is not required in **Redux**, but I recommend this pattern because it decouples your rendering from **Redux**. So if you later choose to move your project to another framework, such as **Relay**, you will not have to change all your components because you can keep the **presentational components** exactly the same.\n\nThis approach also has downsides, such as that you have to thread a lot of props through the components to get them to the list components, including the callbacks. This problem can be easily solved by introducing many intermediate **container components** as we will see in the next lesson.\n","22extractingContainerComponentsFilterLink.md":"In the previous lesson, we separated the **presentational components** from the main **container component**. The `TodoApp` specifies the behaviors, which is what happens when add button, how the to-dos are selected, what happens when a single to-do is being clicked, and what happens when a footer link is clicked.\n\nThe components, such as `AddTodo`, the `TodoList`, the `Todo` itself, the `Footer`, and the `FilterLink`, they don't dispatch actions. They call their callbacks in the props. They are only responsible for the looks but not for the behavior.\n\nThe downside of this approach is that I have to pass a lot of props down the tree even when the intermediate components don't really use them.\n\nFor example, the filter link needs to know the `currentFilter` so that it can choose a different appearance when it is active.\n\n```javascript\nconst FilterLink = ({\n  filter,\n  currentFilter,\n  children,\n  onClick\n}) => {\n  if (filter === currentFilter) {\n    return <span>{children}</span>;\n  }\n```\n\nHowever, in order to receive the `currentFilter`, it has to be passed down from the top. This is why the footer has to accept `visibilityFilter` as a prop, so it can pass it down as a `currentFilter` to the filter link.\n\nIn a way, this breaks encapsulation because the parent components need to know too much about what data the child components need. To solve this, we're going to extract a few more **container components**, just like we extracted the **presentation components** in the previous lesson.\n\nThe first component I'm going to refactor is the `Footer` component. \n\n```javascript\n<Footer\n  visibilityFilter={visibilityFilter}\n  onFilterClick={filter =>\n    store.dispatch({\n      type: 'SET_VISIBILITY_FILTER',\n      filter\n    })\n  }\n/>\n```\n\nCurrently, it accepts two props -- the `visibilityFilter`, and the on `onFilterClick`. But it doesn't actually use either of them. It just passes them down to the filter link. This seems like a good opportunity for simplification.\n\nWe can only do this because we know that the footer component doesn't care about the values of these props. They only exist to be passed down to the filter link that cares about them.\n\n```javascript\n<FilterLink\n  filter='SHOW_ALL'\n  currentFilter={visibilityFilter}\n  onClick={onFilterClick}\n>\n```\n\nI am removing the props definition, and I'm removing these props from the filter link usage. It might start to seem a lot like the the code before separating the **presentational component**. However, what I want to here is a little bit different.\n\n``` javascript\nconst Footer = () => (\n  <p>\n    Show:\n    {' '}\n    <FilterLink\n      filter='SHOW_ALL'\n    >\n      All\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_ACTIVE'\n    >\n      Active\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_COMPLETED'\n    >\n      Completed\n    </FilterLink>\n  </p>\n);\n```\n\nThe filter link does not currently specify the behavior for clicking on the link. It also needs the `currentFilter` to tell whether it should be rendered as active.\n\nTherefore, it's a bit dishonest to say that filter link is a **presentational component** because it is inseparable from its behavior. The only reasonable reaction to clicking on it is setting the `visibilityFilter` by dispatching an action.\n\nThis is why I'm changing it to a different presentational component I'm going to call, `Link` I will create another filter link component as a container that uses it for rendering. The `Link` component doesn't know anything about the filter. It only accepts the active prop, and it calls its own click handler. It is only concerned with rendering.\n\n``` javascript\nconst Link = ({\n  active,\n  children,\n  onClick\n}) => {\n  if (active) {\n    return <span>{children}</span>;\n  }\n\n  return (\n    <a href='#'\n       onClick={e => {\n         e.preventDefault();\n         onClick();\n       }}\n    >\n      {children}\n    </a>\n  );\n};\n```\n\nHowever, I'm also creating another component, called `FilterLink` It is going to be a class this time that is going to render the link with the current data from this store. It's going to read the component props, and it's going to read the state. But I don't mean **react state**. I mean the **Redux store state** it gets by calling, `store.getState`\n\n``` javascript\nclass FilterLink extends Component {\n  render() {\n    const props = this.props;\n    const state = store.getState();\n\n    return (\n      <Link\n        active={\n          props.filter ===\n          state.visibilityFilter\n        }\n      </Link>\n    );\n  }\n}\n```\n\nAs a **container component**, the filter link doesn't have its own markup. It delegates rendering to the link **presentational component**. In this case, it calculates its active prop by comparing its own filter prop with the `visibilityFilter` in the **Redux** store state. The filter prop is the one that is passed to the filter link from the footer. The `visibilityFilter` corresponds to the currently chosen `visibilityFilter` that is held in **Redux store state**. If they match, we want the link to appear active.\n\nThe **container component** also needs to specify the behavior. In this case, the filter link specifies that when this particular link is clicked, we should dispatch the action with the type set `visibilityFilter` and the filter value that we take from the props.\n\n``` javascript\nclass FilterLink extends Component {\n  render() {\n    const props = this.props;\n    const state = store.getState();\n\n    return (\n      <Link\n        active={ ... }\n        onClick={() =>\n          store.dispatch({\n            type: 'SET_VISIBILITY_FILTER',\n            filter: props.filter\n          })\n        }\n      >\n      {props.children}\n      </Link>\n    );\n  }\n}\n```\n\nThe filter link may accept children which are used as the contents of the link, so we're going to pass the children down to the link component. We're just going to render them inside the A tag.\n\nThere is a small problem with this implementation of filter link. Inside the render map, it reads the current state of the **Redux store**. However, it does not subscribe to this store. If the parent component does not update when this store is updated, it's going to render this tail value.\n\nCurrently, we rearrange the whole application when the state changes. However, this is not very efficient. In future, we will instead move subscription to this store, to the lifecycle methods of the **container components**.\n\n``` javascript\nclass FilterLink extends Component {\n  componentDidMount() {\n    store.subscribe(() =>\n      this.forceUpdate()\n  );\n  }\n}\n\nrender() { ... }\n```\n\nReact provides a special force update method on the component instances to force their re-rendering. We're going to use it together with store subscribe method so that any time the store state changes, we force update the **container components**.\n\nWe perform the subscription inside the component did mount lifecycle method. So it's important to unsubscribe inside the component will unmount method. Note that we don't actually have the unsubscribe function, but this is the return value of the store subscribe method, so we can keep it, and then call it inside component will unmount.\n\n``` javascript\nclass FilterLink extends Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n}\n\ncomponentWillUnmount() {\n  this.unsubscribe();\n}\n\nrender() { ... }\n```\n\nLet's recap this part. The `FilterLink` component subscribes to this store, calling force update any time this store changes so it can render the current state of this store. It saves the reference through the unsubscribe function returned by store subscribe. It invokes it when the component is about to unmount to clean up the subscription.\n\nLet's recap the relationship between the `FilterLink` **container component** and the link **presentational component**. The link component only specifies the appearance of the the link, when it is active or inactive, but it doesn't know about the behavior. The filter link component is a container, so it provides the data and the behavior for the **presentational component**.\n\nWhen it mounts, it subscribes to this store, so it independently re-renders when the store state changes because it needs to use this store current state inside its render method.\n\nInstead of specifying the DOM tree, it delegates all the rendering to the link **presentational component**. Its only job is to calculate the props based on the filter link's own props and the current state of the **Redux** store. It also specifies the callbacks that are going to dispatch the actions on this store.\n\n```javascript\nclass FilterLink extends Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n  \n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n  \n  render() {\n    const props = this.props;\n    const state = store.getState();\n    \n    return (\n      <Link\n        active={\n          props.filter ===\n          state.visibilityFilter\n        }\n        onClick={() =>\n          store.dispatch({\n            type: 'SET_VISIBILITY_FILTER',\n            filter: props.filter\n          })\n        }\n      >\n        {props.children}\n      </Link>\n    );\n  }\n}\n```\n\nAfter the action is dispatched, this store will remember the new state returned by the reducer and will call every subscriber to this store. In this case, every `FilterLink` component instance is subscribed to this store, so they will all have their force update methods called on them. They will re-render according to the current store state.\n\nThe filter link is a **container component**, so it is completely self-sufficient and can be used inside the \n**presentational components**, such a footer, without passing additional props to get the data from this store and specify the behavior. This lets us keep the footer component simple and decoupled from the behavior and the data that its child components need.\n","23extractingContainerComponentsVisibleTodoListAddTodo.md":"In the previous lesson, I separated the link **presentational components** from the filter link **container components** that is subscribed to the **Redux store** and that provides the data and the behavior for the link component it renders.\n\nWhile it makes the data flow a little bit less explicit, it makes it easy to use filter link in any component without worrying about passing additional data to the filter link or to the component that contains it. In this lesson we'll continue extracting the **container components** from the top level container component. The first candidate is the `TodoList`  component.\n\nI actually want to keep the `TodoList`  **presentational component**. However, I want to encapsulate within the currently visible ToDos this into a separate **container components** that connects the `TodoList`  to the **Redux store**. I'm going to call this component the visible `TodoList` .\n\n``` javascript\nclass VisibleTodoList extends Component {\n\n}\n```\n\nJust like when declaring the filter link component in the previous lesson, I calculate the data from the current component by using the current state which is the state from the **Redux store**. I'm using the get visible ToDos function to calculate the currently visible ToDos based on all the ToDos from the **Redux store** and the current visibility filter from the **Redux store** state. I'm specifying the behavior as well. I'm saying that when the ToDo is clicked, we should dispatch an action with the type toggle ToDo and the ID of the ToDo being clicked.\n\n``` javascript\nclass VisibleTodoList extends Component {\n  render() {\n    const props = this.props;\n    const state = store.getState();\n\n    return (\n      <TodoList\n        todos={\n          getVisibleTodos(\n            state.todos,\n            state.visibilityFilter\n          )\n        }\n        onTodoClick={id =>\n          store.dipatch({\n            type: 'TOGGLE_TODO',\n            id\n          })\n        }\n      />\n    );\n  }\n}\n```\n\nAll **container components** are similar. Their job is to connect a **presentational components** to the **Redux store** and specify the data and the behavior that it needs. I'm scrolling up to the filter link **container components** I wrote in the previous lesson to copy-paste this store subscription logic.\n\n``` javascript\ncomponentDidMount() {\n  this.unsubscribe = store.subscribe(() =>\n    this.forceUpdate()\n  );\n}\n}\n\ncomponentWillUnmount() {\nthis.unsubscribe();\n}\n\nrender() { ... }\n```\n\nJust like the filter link, the visible `TodoList`  is going to subscribe to this store and force an update any time this store state changes because it uses this state in its render method. Now that the visible `TodoList`  is connected to the **Redux store**, we can use it instead of the `TodoList` . We no longer have to pass all the props from the top.\n\n``` javascript\nconst TodoApp = ({\n  todos,\n  visibilityFilter\n}) => (\n  <div>\n    <AddTodo ... />\n    <VisibleTodoList />\n    <Footer />\n  </div>\n);\n```\n\nFinally, in the previous lesson, I made `AppTodo` a **presentational components**, but I'm going to backtrack on this now. I will copy-paste the dispatch call back in line into the onClick handler inside the component because there isn't really a lot of presentation or behavior here.\n\nIt's easier to keep them together until we figure out how to split the presentation. For example, if in the future, we're going to have something like a form component, we may split it, but for now we'll keep them together.\n\n``` javascript\nconst AddTodo = () => {\n  let input;\n\n  return (\n    <div>\n      <input ref={node => {\n        input = node;\n      }} />\n      <button onClick={() => {\n        store.dispatch({\n          type: 'ADD_TODO',\n          id: nextTodoId++,\n          text: input.value\n        })\n        input.value = '';\n      }}>\n        Add Todo\n      </button>\n    </div>\n  );\n};\n```\n\nI'm scrolling down to my ToDo app component. I'm removing the onAuth click prop. I just noticed that none of the containers actually need any props from this state. I can remove the props of the ToDo app component. I can remove the render function that renders the ToDo app component with the current state of this store because I can just call it once, remove all the props that are related to this state and just render it as is because the **container components** that I render are going to subscribe to this store themselves and are going to update themselves when this store state changes.\n\n``` javascript\nconst TodoApp = () => (\n  <div>\n    <AddTodo />\n    <VisibleTodoList />\n    <Footer />\n  </div>\n);\n\nReactDOM.render(\n  <TodoApp />,\n  document.getElementById('root')\n);\n```\n\nLet's recap the data flow after separating the **presentational** and the **container components**. There is just one **react** on render call at the very end. We don't render again when this store state changes because the **container components** take care of that.\n\n```javascript\nconst TodoApp = () => (\n  <div>\n    <AddTodo />\n    <VisibleTodoList />\n    <Footer />\n  </div>\n);\n\nReactDOM.render(\n  <TodoApp />,\n  document.getElementById('root')\n);\n```\n\nThe first component I'm looking at is called `AddTodo`. Frankly, I can classify it either as a **presentational components** or as a **container components** because it doesn't fit either category. The input and the button are the presentational part, but dispatching an action onClick is the behavior which is usually specified by the container.\n\n\n```javascript\nconst AddTodo = () => {\n  let input;\n\n  return (\n    <div>\n      <input ref={node => {\n        input = node;\n      }} />\n      <button onClick={() => {\n        store.dispatch({\n          type: 'ADD_TODO',\n          id: nextTodoId++,\n          text: input.value\n        })\n        input.value = '';\n      }}>\n        Add Todo\n      </button>\n    </div>\n  );\n};\n```\n\nHowever, in this case, I'd rather keep them together because there isn't any state, the UI is very simple. It's hard to imagine any other behavior other than dispatching the `AddTodo` action.\n\nThe second component are rendering inside the at `TodoApp` is called the `VisibleTodoList` . This time, it is a proper **container components** that subscribes to this store and re-renders the `TodoList`  any time this store state changes. It calculates the visible ToDos from the current **Redux store** state, the ToDos and the \n`visibilityFilter` fields. It passes them as the To-Dos.\nWhen the To-Dos are clicked, it's going to dispatch an action with the type `TOGGLE_TODO` and the `ID` of the respective ToDo.\n\n```javascript\nclass VisibleTodoList extends Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n  \n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n  \n  render() {\n    const props = this.props;\n    const state = store.getState();\n    \n    return (\n      <TodoList\n        todos={\n          getVisibleTodos(\n            state.todos,\n            state.visibilityFilter\n          )\n        }\n        onTodoClick={id =>\n          store.dispatch({\n            type: 'TOGGLE_TODO',\n            id\n          })            \n        }\n      />\n    );\n  }\n}\n```\n\nThe actual rendering here is performed by the `TodoList`  component that just renders the ToDos passed through it as prop and binds their clicks through the on `onTodoClick` prop.\n\nFinally, the last component `TodoApp` renders is the footer. The footer is just a **presentational component** rendering three different filter links. The `FilterLink` is a **container component**. It subscribes to this store and it renders the **presentational component** called, \"link,\" calculating whether it should be active based on its props and the current **Redux store** state and specifies the behavior what happens when it's clicked.\n\n```javascript\nclass FilterLink extends Component {\n  componentDidMount() {\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n  \n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n  \n  render() {\n    const props = this.props;\n    const state = store.getState();\n    \n    return (\n      <Link\n        active={\n          props.filter ===\n          state.visibilityFilter\n        }\n        onClick={() =>\n          store.dispatch({\n            type: 'SET_VISIBILITY_FILTER',\n            filter: props.filter\n          })\n        }\n      >\n        {props.children}\n      </Link>\n    );\n  }\n}\n```\n\nFinally, the link component is just a **presentational component** that render a-tag. Separating the container and the **presentational component** is often a good idea, but you shouldn't take it as a dogma. Only do this when it truly reduces the complexity of your code base.\n\n```javascript\nconst Link = ({\n  active,\n  children,\n  onClick\n}) => {\n  if (active) {\n    return <span>{children}</span>;\n  }\n\n  return (\n    <a href='#'\n       onClick={e => {\n         e.preventDefault();\n         onClick();\n       }}\n    >\n      {children}\n    </a>\n  );\n};\n```\n\nIn general, I suggest first trying to extract the **presentational component**. If there is too much boilerplate passing the props through them, then you can create the containers around them that load the data and specify the behavior.\n","24passingTheStoreDownExplicitlyViaProp.md":"In the previous lessons, we used this `store` to up level variable to refer to the **Redux store**. The components that access this store, such as the **container components**, read this state from it, subscribe to this store, and dispatch actions on this store using this store top-level variable.\n\nThis approach works fine for JS bin example where everything is in a single file. However, it doesn't scale to real applications for several reasons.\n\nFirst of all, it makes your **container components** harder to test because they reference a specific store, but you might want to supply a different marks store in the test. Secondly, it makes it very hard to implement universal replications that are rendered on the server, because on the server, you want to supply a different store instance for every request because different requests have different data.\n\nI'm going to start by moving this store creation code to the bottom of the file where I render my **React components**. I'm going to change it slightly. Instead of creating this store top-level variable, I will pass this store I create as a prop to the top-level component, so it is completely injectable into it.\n\n``` javascript\nReactDOM.render(\n  <TodoApp store={createStore(todoApp)} />,\n  document.getElementById('root')\n);\n```\n\nEvery **container component** needs a reference to this store so unfortunately, we have to pass it down to every component as a prop. It's less effort than passing different data through every component, but it's still inconvenient. So, don't worry, we'll find a better solution later, but for now, we need to see the problem.\n\n``` javascript\nconst TodoApp = ({ store }) => (\n  <div>\n    <AddTodo store={store} />\n    <VisibleTodoList store={store} />\n    <Footer store={store} />\n  </div>\n);\n```\n\nThe problem is that the **container components** need to have this store instance to get this state from a dispatch actions and subscribe to the changes. This time, I'm changing the **container component** to take this store from the props using the ES6 destruction syntax, which just means \"store equals props does store.\"\n\nI'm doing the same here. I'm just taking this store from the props so I can call dispatch on it.\n\n``` javascript\nclass VisibleTodoList extends Component {\n  componentDidMount() {\n    const { store } = this.props;\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n\n  componentWillUnmount() { ... }\n\n  render() {\n    const props = this.props;\n    const { store } = props;\n    const state = store.getState();\n\n    return (\n      <TodoList ... />\n    );\n  }\n}\n```\n\nI need to make similar changes to other **container components**. In this case, I have this `AddTodo` component, which is not exactly a **container component**, but it still needs its store to dispatch the `ADD_TODO` action, so I added it as a prop. I'm also going to add this store to the `Footer` component because, unfortunately, `filterLink` needs it.\n\n``` javascript\nconst Footer = ({ store }) => (\n  <p>\n    Show:\n    {' '}\n    <FilterLink\n      filter='SHOW_ALL'\n      store={store}\n    >\n      All\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_ACTIVE'\n      store={store}\n    >\n      Active\n    </FilterLink>\n    {', '}\n    <FilterLink\n      filter='SHOW_COMPLETED'\n      store={store}\n    >\n      Completed\n    </FilterLink>\n  </p>\n);\n```\n\nThe photo component renders `filterLink`. This is not convenient, but as I said, we'll figure out a way to avoid this later. For now, we need to pass this store down so that every **container component**, such as `filterLink`, can use it to subscribe to the changes, to read this state and to dispatch actions without relying on a top-level variable being available.\n\n``` javascript\nclass FilterLink extends Component {\n  componentDidMount() {\n    const { store } = this.props;\n    this.unsubscribe = store.subscribe(() =>\n      this.forceUpdate()\n    );\n  }\n\n  componentWillUnmount() {\n    this.unsubscribe();\n  }\n\n  render() {\n    const props = this.props;\n    const { store } = props;\n    const state = store.getState();\n\n    return ( ... );\n  }\n}\n```\n\nI'm changing the render method to read this store from the props. Now, all containers read this store instance from the props, and don't rely on a top-level variable that I removed.\n\n```javascript\nrender() {\n    const props = this.props;\n    const { store } = props;\n    const state = store.getState();\n```\n\nNote that this change did not change the behavior or the data flow of this application. The **container components** subscribe to this store, just like before, and update their state in response to its changes.\n\nHowever, what changed is how they access this store. Previously, they would access a top-level variable, but this approach does not scale to real-world applications. This is why, right now, I'm passing down this store as a prop, so the **container components** can subscribe to it.\n\nIn the future lessons, we will see how to pass this store down to the **container components** implicitly but without introducing the top-level variable.\n","25passingTheStoreDownImplicitlyViaContext.md":"In the previous lesson, we got rid of the top level store variable and instead starting passing this store as a prop to the `TodoApp` component. So every component below receives this store as a prop. We even have to do this for **presentational components** because sometimes they contain **container components** that need this store to subscribe to the changes.\n\nWe have to write a lot of boiler plate code to pass this store down as a prop. But there is another way, using the advanced React feature called context.\n\nI'm creating a new component called `Provider`. From its `render` method, it just returns whatever its child is. We can wrap any component in a `Provider`, and it's going to render that component.\n\n``` javascript\nclass Provider extends Component {\n  render() {\n    return this.props.children;\n  }\n}\n```\n\nI'm changing the render call to render a `TodoApp` inside the `Provider`. I'm moving this tool prop from the `TodoApp` to the `Provider` component. The `Provider` component will use the React advanced context feature to make this store available to any component inside it, including grandchildren.\n\n``` javascript\nReactDOM.render(\n  <Provider store={createStore(todoApp)}>\n    <TodoApp />\n  </Provider>,\n  document.getElementById('root')\n);\n```\n\nTo do this, it has to define a special method get child context that will be called by React by using this props store which corresponds to this store that is passed to the `Provider` as a prop just once.\n\n``` javascript\nclass Provider extends Component {\n  getChildContext() {\n    return {\n      store: this.props.store\n    };\n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n```\n\nThis tool will be part of the context that the `Provider` specifies for any its children and grandchildren. The `TodoApp` is going to receive this context, and any component inside `TodoApp` is also going to receive this context object with this tool inside it.\n\nHowever, there is an important condition for the context to work. This condition is that you have to specify child context types on the component that defines get child context. These are just React prop types definition, but unlike prop types, the child context types are essential for the context to be turned on. If you don't specify them, no child components will receive this context.\n\n``` javascript\nclass Provider extends Component {\n  getChildContext() { ... }\n\n  Provider.childContextTypes = {\n    store: React.PropTypes.object\n  };\n\n  render() { ... }\n}\n```\n\nThe **container components** currently access tool by props, but we're going to change this to read this store from React context. To do that, we just wrap it to `this.context`. Similarly, in the render method, I'm also going to read this store from the context instead of the props.\n\nFinally, the context is opt-in for the receiving components, too, so you have to specify a special field called `contextTypes`, which are similar to child context type. But, in this case, we are specifying which context we want to receive and not pass down. If you forget to declare the context types, the component will not receive the relevant context, so it is essential to remember to declare them.\n\n``` javascript\nVisibleTodoList.contextTypes = {\n  store: React.PropTypes.object\n};\n```\n\nWhat about the functional components that don't have this? It turns out that they also receive the context but as a second argument after the props. I'm destructuring the second argument and getting this store from there. The second argument is the context.\n\n``` javascript\nconst AddTodo = (props, { store }) => { ... }\n```\n\nJust like with the class components, I still have to add a property called, `contextTypes` that specifies which context I want to receive. In this case, I want to receive the store from the `Provider`. If I forget to declare the context types, my functional component will not receive the relevant context as a second argument. It's important to remember to declare them any time you use the context.\n\n``` javascript\nAddTodo.contextTypes = {\n  store: React.PropTypes.object\n};\n```\n\nFinally, I'm replacing the props with the context when getting this store for the `FilterLink`. I'm adding the context type declaration to the `FilterLink` so it receives the relevant context from the `Provider`.\n\n``` javascript\nFilterLink.contextTypes = {\n  store: React.PropTypes.object\n};\n```\n\nNow that the `FilterLink` receives this store by context, I no longer need to pass it as a prop, so I'm removing its usage. I'm also removing the store prop from the footer because it doesn't need to pass it down anymore. I'm also removing this store prop from the `TodoApp` component because I no longer need to pass it down to the containers.\n\nNow, instead of explicitly passing this store down by props, we pass it implicitly by context.\n\nLet's recap how we use the context to pass this store down. We start by rendering the `TodoApp` inside the `Provider` component we defined above. The `Provider` component just renders whatever you pass through it. In this case, it renders its children or the `TodoApp` component. However, it also provides the context to any components inside it including grandchildren.\n\nThe context contains just one key called the `store`. It corresponds to the `store` we passed as a prop to the `Provider` component.\n\n```javascript\nclass Provider extends Component {\n  getChildContext() {\n    return {\n      store: this.props.store\n    }; \n  }\n\n  render() {\n    return this.props.children;\n  }\n}\n```\n\nWe pass this `store` to the `Provider` component in our render code and make it available to child components by defining the get child context with the `store` key pointing to that prop.\n\nIt is essential that the `getChildContext` is matched by `childContextTypes` where we specify that the store key has prop type of object. Note that the child context types definition is absolutely required if you want to pass the context down the tree.\n\n```javascript\nProvider.childContextTypes = {\n  store: React.PropTypes.object\n};\n```\n\nThe benefit is that we don't need to pass this `store` through the intermediate components. Instead, we can declare the context types on the **container components** that need access to the `store` so that they can retrieve it from the context instead of retrieving it from the props.\n\nThe context creates something like a wormhole between the `VisibleTodoList` component that reads the context and the `Provider` that provides the context. This wormhole is only enabled because the context types declared on the `VisibleTodoList` include this `store` that is defined in child context types of the `Provider` component.\n\nThe `AddTodo` is another component that needs access to this `store`. It also opts into receiving it in the context by specifying the context types. This is why, in addition to props, it receives a second argument, which is the context. I'm using the destruction syntax to grab this store from the context here.\n\n```javascript\nAddTodo.contextTypes = {\n  store: React.PropTypes.object\n};\n```\n\nThe context works at any depth, so it is not necessary to put context types on the footer. The `FilterLink` is the component that directly uses the context, so this is the component that has to specify the context types so that it can use this store by reading it from the context.\n\nContext is a powerful feature, but in a way it contradicts the React philosophy of the explicit data flow. The context essentially allows global variables across the component tree. But global variables are usually a bad idea. Unless you're using it for dependency injection, like here when we need to make a single object available to all components, then probably you shouldn't use context.\n\nFinally, the context API is **not stable** in React. It has changed before, and it is likely to change again. Try your best not to rely on it too much.\n","26passingTheStoreDownWithProviderFromReactRedux.md":"In the previous session, we implemented the `Provider` component that uses the react advanced context feature to make this tool from the props available to every component in our rev.\n\nIf we pass it through the `Provider`, we can read it in any other component from the context, which is really convenient for the **container components**. In fact, this is so convenient that you don't need to actually write the `Provider` yourself, because it is included in a special library called **React-Redux**.\n\nNote that it is not the same as **Redux**. This is a different library. These are react bindings to the Redux library. You can import the `Provider` by **destructuring** the react-redux global object in JS bin, or if you use **Babel**, and something like **NPM**, you can import `Provider` with the braces, because it's a named expert from **React-Redux** package. Or if you write **ES5** code, you can write `var Provider = require('react-redux').Provider;`\n\n``` javascript\nconst { Provider } = ReactRedux;\n```\n\nJust like the `Provider` we wrote before, the `Provider` that comes with **react-redux** exposes this store you passed through. There's a prop on the context so the components can specify the context types, and then use this context store to subscribe to the store updates and dispatch actions.\n","27generatingContainersWithConnectReactReduxVisibleTodoList.md":"In the previous lesson, I added `ReactRedux` bindings to the project and I used a `Provider` component from `ReactRedux` to pass this store down the context so that the **container components** can read the store from the context and subscribe to these changes. All **container components** are very similar.\n\nThey need to re-render when the store state changes, they need to unsubscribe from the store when they amount and they take the current state of the Redux store and use it to render the **presentational components** with some props that they calculate from the state of this `store`, and they also need to specify the context stripes to get this `store` from the context.\n\nI'm going to write this component in a different way now. I'll declare a function called `mapStateToProps` which takes the redux store state and returns the props that I need to parse through the presentation to do this component, to render it with the current state.\n\nIn this case, there is a single prop called `ToDo`. I copy-paste this expression to the `mapStateToProps` function. It returns the props that depend on the current state of the redux store. In this case, this is just the `ToDolist` prop.\n\n``` javascript\nconst mapStateToProps = (state) => {\n  return {\n    todos: getVisibleTodos(\n      state.todos,\n      state.visibilityFilter\n    )\n  };\n};\n```\n\nI'm creating another function that I call `mapDispatchToProps`. It accepts the `dispatch` method from this `store` as the only argument and returns the props that should be parsed through the list component and that depend on the `dispatch` method.\n\nThe only prop that uses store `dispatch` is called `onTodoClick`. Some copy-paste onto the click, into `MapDispatchToProps`. Now that I don't have the reference to this `store` here anymore. Instead, I'm changing it to use the `dispatch`, which is provided as an argument to `mapDispatchToProps`.\n\n``` javascript\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    onTodoClick: (id) => {\n        dispatch({\n        type: 'TOGGLE_TODO',\n        id\n      })\n    }\n  };\n};\n```\n\nI will add some punctuation to make it appear easier on my eyes. `onTodoClick` ease of function that accepts the `ID` of the `ToDo`, and dispatches an action. Now, I've got two different functions.\n\nThe first one maps the redux store state to the props of the `ToDoList` component that are related to the data from the redux store. The second function maps the dispatch method of this store to the callback props of `ToDoList` component. It specifies the behavior which callback prop dispatches which action.\n\nTo gather this, your function has described a **container component** so well that instead of writing it, I can generate it by using the `connect` function provided by `ReactRedux` library. If you use **Babel** and NPM, you will likely input it like this instead. Don't forget the curly braces.\n\n``` javascript\nconst { connect } = ReactRedux;\n```\n\nNow, instead of declaring a class, I'm going to declare a variable. I will call the connect method to obtain it. I'm parsing `mapStateToProp` as the first argument and `mapDispatchToProps` as the second argument. Notice that this is a correct function, so I have to call it once again. This time, I parse the **presentational component** that I wanted to wrap and pass the props to you.\n\n``` javascript\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList);\n```\n\nThe `connect` function will generate the component, just like the one I previously wrote by hand. I don't need to write the code to subscribe to this store or to specify the context types, because the connect function takes care of that.\n\n```javascript\nconst { connect } = ReactRedux;\nconst VisibleTodoList = connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(TodoList);\n```\n\nNow, let's recap how to generate the **container component** using the `connect` function. First, I'll write a function called `mapStateToProps` that takes the state of the redux store and returns the props for the **presentational component** calculated from it.\n\nThese props will be updated anytime the state changes.\n\n```javascript\nconst mapStateToProps = (state) => {\n  return {\n    todos: getVisibleTodos(\n      state.todos,\n      state.visibilityFilter\n    )\n  };\n};\n```\n\nNext, I write a function that I call `mapDispatchToProps`. It takes these store's `dispatch` method as its first argument. It returns the props that used the `dispatch` method to dispatch options, so it returns the callback props needed for the **presentational component**.\n\n```javascript\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    onTodoClick: (id) => {\n      dispatch({\n        type: 'TOGGLE_TODO',\n        id\n      });\n    }\n  };\n};\n```\n\nTo create the **container component** from them, I import connect from the `ReactRedux` library and I call it passing `mapStateToProps` as the first argument and will dispatch the props as a second argument.\n\nFinally, I close the function called Param and I open another param, because this is a parent function and it needs to be called twice. The last argument is the **presentational component** that I want to connect to the redux store.\n\nThe result of the connect call is the **container component** that is going to render my **presentational component**. It will calculate the props to pass through the **presentational component** by merging the objects returned from `mapStateToProps`, `mapDispatchToProps`, and its own props.\n","28generatingContainersConnectReactReduxAddTodo.md":"In the previous lesson, we used the `connect` function from `ReactRedux` bindings library to generate the **container component** that renders our **presentational component**. I specify how to calculate the props to inject from the current Redux store state and the callback props to inject from the dispatch function on the Redux store.\n\nNormally, I would keep these functions, call map state to props and map dispatch to props, but I'm working in a single file right now. I need to write these functions for if your other **container components**, so I'm going to rename them to something more specific, which you don't have to do in your code if you keep every component in its own file.\n\nI will also remove the line breaks here to make it clear that these functions are only relevant for generating this particular **container component**.\n\nNow I'm scrolling up to the `AddTodo` component, which is not clearly **presentational** or a **container component**. However, it uses this `store`. It reads this store from the context to dispatch an action when the button is clicked. It has to declare the context types to be able to grab this store from the context.\n\n``` javascript\nconst mapStateToTodoListProps = ( ... ) => { ... }\nconst mapDispatchToTodoListProps = ( ... ) => { ... }\n```\n\n**Context** is an unstable API, so it's best to avoid using it in your application code. Instead of reading this store from the context, I will read the `dispatch` function from the props because I only need the dispatch here. I don't need the whole store.\n\nI will create a **container component** with connect that will inject that the `dispatch` function as a prop. I will remove the context types because the component generated by `connect` function will take care of reading this store from the context.\n\nBecause I changed the `AddTodo` declaration from the const to the let binding, I can reassign it now so that the consuming component does not need to specify the dispatch prop because it will be injected by the component generated by the `connect` code.\n\nThe first argument to the `connect` function is map `state` to props, but there aren't any props for `AddTodo`component that depend on the current state, so I return an empty object. The second argument to connect is map `dispatch` to props, but `AddTodo` component doesn't need any callback props. It just accepts the `dispatch` function itself, so I'm returning it as a prop with the same name.\n\n``` javascript\nAddTodo = connect(\n  state => {\n    return {};\n  },\n  dispatch => {\n    return { dispatch };\n  }\n)(AddTodo);\n```\n\nFinally, I'm calling the function for a second time to specify the component I want to wrap, in this case, `AddTodo` itself. The generated **container component** will not pass any props dependent on the state, but it will pass `dispatch` itself as a function so that the component can read from the props and use it without worrying about context or specifying context types.\n\nHowever, it is wasteful to even subscribe to this store if we don't calculate any props from its state. So I'm replacing the maps state to props function with an `null`, which tells `connect` that there is no need to subscribe to this store.\n\n``` javascript\nAddTodo = connect(\n  null,\n  dispatch => {\n    return { dispatch };\n  }\n)(AddTodo);\n```\n\nAdditionally, it's pretty common pattern to inject just the `dispatch` function. This is why if you specify null or any false value in connect as the second argument, you're going to get dispatch injected as a prop. In fact, I can just remove all arguments here. The default behavior will be to not subscribe to this store and to inject just the `dispatch` function as a prop.\n\n``` javascript\nAddTodo = connect()(AddTodo);\n```\n\nLet's recap what happens to the components here. The `AddTodo` component that I declare accepts `dispatch` as a prop, but it doesn't know how to get this store. It just hopes that someone is going to pass the dispatch to it.\n\nThe `connect` code without any arguments is going to generate a **container component** that does not subscribe to this store. However, that will pass dispatch to the component that it wraps. In this case, it wraps my `AddTodo` component.\n\nThe second connect call returns the generated **container component**. I'm assigning it to `AddTodo`. I'm reassigning the `let` binding the second time.\n\nWhen the further code references `AddTodo`, it's going to reference the **container component** that does not need the `dispatch` prop and that will pass the `dispatch` prop to my inner `AddTodo` component that I don't have a reference to anymore.\n","29generatingContainersConnectReactReduxFooterLink.md":"Finally, let's take a look at the `FilterLink` **container component** that renders a link with an active property and a click handler. First, I will write the map state to props function, which I'll call, \"maps state to link props,\" because I have everything in a single file.\n\nIt's going to accept the state of the Redux store and return the props that should be passed to the link. We only have a single such prop called, \"active\" that determines whether the link displays the current `Visibility Filter`.\n\n``` javascript\nconst mapStateToLinkProps = (\n  state,\n  ownProps\n) => {\n  return {\n    active:\n      ownProps.filter === state.visibilityFilter\n  }\n}\n```\n\nWhen I paste this expression from the render method, I see that it references the filter prop of the `FilterLink` component. To tell whether a link is active, we need to compare this prop with the `Visibility Filter` value from the Redux store sheet.\n\nIt is fairly common to use the container props when calculating the child props, so this is why props are passed as a second argument to `mapStateToProps` I will rename it to `ownProps` to make it clear we are talking about the **container component**'s `ownProps` and not the props that are passed through the child, which is the return value of `mapStateToProps`\n\nThe second function I'm writing here is `mapDispatchToProps` or, to avoid name clashes in this JS bin, `mapDispatchToLinkProps` The only argument so far is the `dispatch` function. I'm going to need to look at the **container component** I wrote by hand to see what props depend on the `dispatch` function.\n\nIn this case, this is just the click handler where I dispatch the `SET_VISIBLITY_FILTER` direction. The only prop I'm passing down is called, `onClick` I declare it as an **arrow function** with no arguments, and I paste the `dispatch` code. But it references the props again, so I need to add `ownProps` as an argument, the second argument, to map dispatch to props function to you.\n\n``` javascript\nconst mapDispatchToLinkProps = (\n  dispatch,\n  ownProps\n) => {\n  onClick: () => {\n    dispatch({\n      type: 'SET_VISIBILITY_FILTER',\n      filter: ownProps.filter\n    })\n  };\n}\n```\n\nFinally, I will call the `connect` function from `ReactRedux` library to generate the `FilterLink` **container component**. I pass the relevant `mapStateToProps` function as the first argument, the `mapDispatchToProps` as the second argument, and I call the function again with a link component which should be rendered. Now I can remove the old `FilterLink` implementation.\n\n``` javascript\nconst FilterLink = connect(\n  mapStateToLinkProps,\n  mapDispatchToLinkProps\n)(Link);\n```\n\nLet's recap the data flow in this example. The `Footer` component renders three `filter` links, and each of them has a different filter prop that specifies which filter it corresponds to. This prop will be available on the `ownProps` object that both `mapDispatchToProps` and `mapStateToProps` will receive as the second argument.\n\nWe pass these two functions through the `connect` call, which will return a **container component** called, `FilterLink`. The `FilterLink` will take the props that will return from the `mapDispatchToProps` and `mapStateToProps` and pass them as props to the link component that it wraps.\n\nWe can now use the `FilterLink` **container component** and specify just the filter, but the underlying link component will have received the calculated active and `onClick` values.\n","30extractingActionCreators.md":"So far we have covered the **container components**, the **presentational components**, the reducers, and the store. But we have not covered the concept of **action creators**, which you might see in the Redux talks and examples.\n\nLet's consider the following example. I dispatched the `ADD_TODO` action from inside the `button onClick` handler. This is fine. However, it references the `nextTodoId` variable, which added there alongside the add todo component.\n\n```javascript \nlet nextTodoId = 0;\nlet AddTodo = ({ dispatch }) => {\n  let input;\n\n  return (\n    <div>\n      <input ref={node => {\n        input = node;\n      }} />\n      <button onClick={() => {\n        dispatch({\n          type: 'ADD_TODO',\n          id: nextTodoId++,\n          text: input.value\n        })\n        input.value = '';\n      }}>\n        Add Todo\n      </button>\n    </div>\n  );\n};\n```\n\nNormally, it would be local. However, what if another component wants to dispatch the `ADD_TODO` action? It would need to have the access to `nextTodoId` somehow. While I could make this variable **global**, it's not a very good idea.\n\nInstead, it would be best if the components dispatching the `ADD_TODO` action did not have to worry about specifying the `ID`. Because the only information they really pass is the text of the todo being added.\n\nI don't want to generate the `ID` inside the reducer, because that would make it **non-deterministic**. However, I can extract this code generating the action object into a function I will call `addTodo`.\n\nI pass the input value to `addTodo`. `addTodo` is just the function that takes the text of the todo and constructs an action object representing `ADD_TODO` action. It has the type, `ADD_TODO`, it takes care of generating the unique `ID` and it includes the text.\n\n``` javascript\nconst addTodo = (text) => {\n  return {\n    type: 'ADD_TODO',\n    id: nextTodoId++\n    text\n  };\n};\n```\n\nAlthough extraction such functions is not required, it is very common pattern in Redux applications to keep them maintainable, so, like all these functions, action creators, and we usually place them separately from components or from reducers.\n\nI will now extract other **action creators** from the components. I see that I have it `setVisibilityFilter` the dispatch there, so I will change this to call this `setVisibilityFilter` action creator with own props filter as the argument and is going to return the action that needs to be dispatched, so I'm declaring this `setVisiblityFilter` function.\n\n``` javascript\nconst mapDispatchToLinkProps = ( ... ) => {\n  onClick: () => {\n    dispatch(\n      setVisibilityFilter(ownProps.filter)\n    );\n  }\n}\n```\n\nThis is what I call an **action creator**, because it takes the arguments about the action and it returns the action object with the type `SET_VISIBILITY_FILTER` and the filter itself.\n\n``` javascript\nconst setVisibilityFilter = (filter) => {\n  return {\n    type: 'SET_VISIBILITY_FILTER',\n    filter\n  };\n};\n```\n\nYou might think that this kind of code is boilerplate and you'd rather dispatch the action in line inside the component. However, don't underestimate how **action creators** document your software, because they tell your team what kinds of actions the components can dispatch, and this kind of information can be **invaluable** in large applications.\n\nI will now scroll down to the last place where I call dispatch with an inline action object. I will now extract that to add toggle todo action creator, to which I pass the ID of the todo as the argument.\n\n```javascript\nconst mapDispatchToTodoListProps = (\n  dispatch\n) => {\n  return {\n    onTodoClick: (id) => {\n      dispatch(toggleTodo(id));\n    }\n  };\n};\n```\n\nI'm now scrolling up to my **action creators** and I will add a new one that I call `toggleTodo`. It accepts the `ID` as the argument and it returns the action of the type, `TOGGLE_TODO`, and this `id`.\n\n```javascript\nconst toggleTodo = (id) => {\n  return {\n    type: 'TOGGLE_TODO',\n    id\n  };\n};\n```\n\nLet's take a moment to consider how convenient it is to have all the **action creators** in a single place so that I can use them from components and tests without worrying about the action's internal structure.\n\nKnow that whether you use action creators or not, the data flow is exactly the same, because I just call the **action creator** to get the **action object** and then I call `dispatch` just like I did before, passing the action.\n"}

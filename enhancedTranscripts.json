[{"lesson_slug":"arrow-function","enhanced_transcript":"Let's rewrite this `createGreeting` function to the **arrow function** style. Let's say `arrowGreeting` is message name and then the **fat arrow** with some braces and `return message + name`. Now, that actually looks about the same.\n``` javascript\nvar createGreeting = function(message, name){\n  return message + name;\n}\n\nvar arrowGreeting = (message,name) => {\n  return message + name;\n}\n```\nThe only difference really is that this is on the right side, whereas the `function` keyword is on the left side, so that'd be here, whereas this would go here. But we can actually make this much smaller.\n\nFirst, let's remove the braces. I'll remove him, remove him, and move everything up the same line and remove the `return` keyword. This will automatically return `message + name`. You don't have to write the `return` keyword when you don't have the braces in there.\n``` javascript\nvar arrowGreeting = (message,name) => message + name;\n\n```\nSecond, if there's **only one parameter**, like you only take in a `message`, you can actually get rid of the **surrounding parens** here and just say `message` would return `message`, or `message` would return `hello`, or whatever you want it to **return**. That's why you'll see something like `var squared` is X, which returns `X * X` to be `X squared`.\n``` javascript\nvar arrowGreeting = message => \"hello\";\n\nvar squared = x => x * x;\n```\nAn extremely common scenario that you've probably run into before whether though **click handlers** or anything else is that, you write a function to handle some sort of action and you write the body of the function, and you run into the scenario where you'll assign `that = this` because you actually want to get the name off of the parent scope.\n``` javascript\nvar deliveryBoy = {\n  name: \"John\",\n\n  handleMessage: function (message, hangler) {\n    handler(message);\n  },\n\n  receive: function () {\n    var that = this;\n\n    this.handleMessage(\"Hello, \", function(message) {\n      that.name //get the proper name\n\n      console.log(message + that.name);\n    })\n  }\n}\ndeliverBoy.receive();\n```\nThe name doesn't exist inside of this scope so we have to do the `that` is `this`, and then, to get `this` in here, you refer to `that`. It can get pretty confusing.\n\nNow, the **arrow function** actually helps handle this scenario. I'm going to delete the `function` keyword. I'll use the arrow function syntax. Then, that here can just become this. I can delete this line, delete `that`, and `this` now refers to the outer scope outside of this function because it's passing in this **lexical scope** that's coming in from **above** the function.\n``` javascript\nreceive: function () {\n\n  this.handleMessage(\"Hello, \", (message) => {\n        console.log(message + this.name);\n      })\n}\n```\n`this` is no longer referring to the **scope** inside of the function. It's referring to the scope that's outside of the function.\n\nAgain, if you'd prefer to do this in one line of code, we can delete this brace and bring everything up a line. We can delete the semicolon and delete the closing brace. We can remove the paren from here and handle this nicely in a simple one-liner.\n``` javascript\nreceive: function () {\n\n  this.handleMessage(\"Hello, \", message => console.log(message + this.name))\n}\n```\nWhen I run this, you can see it prints out `Hello, John` because this is actually this handler right here and it's getting this message through here, which is coming from here. When the message goes here to here to here, down into our arrow function, I add it to this name, and `this.name` is this name now..."},{"lesson_slug":"ecmascript-6-const-declarations-in-es6-es2015","enhanced_transcript":"As a developer coding in JavaScript with **ES5**, if you want to declare a **variable** whose value is to remain constant, it's a best practice to name that variable in all **upper case letters**. This **doesn't actually prevent** the variable from being **reassigned** to a different value, but is more like a note to other developers, saying, \"Hey, this is my intention.\" \n``` javascript\nvar VALUE = 'hello world';\nVALUE = 'foo bar';\nconsole.log('value: ', VALUE);\n```\nNotice how if I console log out `value`, what is returned to us is `foo bar`, because that's the last assignment that was given to that variable.\n\n**ECMAScript 2015** introduces us to **constant** declaration, a `const` declaration allows us to declare a variable that is **read only**. \n``` javascript\nconst VALUE = 'hello world';\nVALUE = 'foo bar';\nconsole.log('value: ', VALUE);\n```\nIn the example if I try to reassign the value to `foo bar`, we'll see the value is **read only error** thrown, because we have declared this variable as a constant. It's important to understand that what a `const` is, is not actually a constant variable, but a **constant reference**.\n\n![Read Only Error](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-const-declarations-in-es6-es2015-read-only-error.png)\n\nIn the example, I have declared **value** to be an **object**. Down below, I can **assign** and reassign **properties** of that object without breaking my const rules. If I `console.log()` out `value`, we'll see an object with a **key-value pair** of `foo: bar` returned to us. However, if I try to reassign the value of `foo` to just the **string literal** `bar`, our value is read only error is once again thrown, because I have **changed the reference** of this const declaration. There are many common use cases for why you might want to use a `const` in your application.\n\nPerhaps you're using a third-party API, where you want to specify an **API key**, an **API secret** that will remain constant throughout the use of your application. Some other common use cases include assigning a **port number** in a node application, perhaps creating a margin that is used for profit and loss calculations within an application, or maybe you just want a constant reference to pi, which you know will not change.\n\nAnother important thing to note is that like [let declaration](https://egghead.io/lessons/the-let-keyword),`const` declarations adhere to **block scope**. Block scope can simply be understood as anything between two curly brackets. In the example, `if true { const foo = bar }`, and then outside of those curly brackets I try to `console.log(foo)`, we will see the error `foo is not defined`. This is because the `console.log` is outside of the scope of the `const` declaration. \n``` javascript\nif(true){\n  const foo = 'bar';\n}\nconsole.log('foo: ', foo); // foo is not defined\n```\nHowever if we move the `console.log` within that block scope, we'll see that `bar` is returned.\n``` javascript\nif(true){\n  const foo = 'bar';\n  console.log('foo: ', foo);\n}\n```"},{"lesson_slug":"ecmascript-6-converting-an-array-like-object-into-an-array-with-array-from","enhanced_transcript":"Here we have a list of `prices` that belong to `products` inside of a `store`. We'd like to highlight the `prices` that are less than $10, and we don't have access to the server code to be able to do that on the server. So we're going to do it with **JavaScript** on the **client**. Let's grab our `products` and store them in a variable called `products`, and we'll do that by saying `document.querySelectorAll('')`, and we know that each of these has a class name of `.product`, so we'll use that to grab them.\n```javascript\nconst products = document.querySelectorAll('.product');\n\nconsole.log(products)\n```\nThen let's log these out, see what they contain. So we can see that we have our `products` and if we open this up, we can see that they are of the type **NodeList**, and the problem with the NodeList is that it's like an array but it's **not** an **array**, so it doesn't have all of the typical array **methods** that we want to use like `filter`, and `forEach`, and `reduce`. \n\n![NodeList](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-converting-an-array-like-object-into-an-array-with-array-from-NodeList.png)\n\nWhat we can do is we can convert this NodeList into an array, and then we'll be able to use the array methods on the lists.\n\nIn the past there's been a lot of hackey ways to do this, but now with **ECMAScript 2015** we have a **native way** to do it with the `array.from` method. So I'm going to go up here and wrap my NodeList here with `array.from`. \n\nIf we log this out, we'll be able to see if we open this up again, that it's now of type array. Now we can use the array methods to solve our original problem of highlighting numbers that are less than 10 in the list.\n```JavaScript\nconst products = \nArray.from(document.querySelectorAll('.product'));\n```\n\n![Array](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-converting-an-array-like-object-into-an-array-with-array-from-Array.png)\n\nWhat I'm going to do now is say `products`, and we'll `filter` those products, and we'll filter if the product, the number inside of that product, supply `parseFloat` and we'll grab the `product.innerHTML`, and we'll check if it is less than $10. Then when we get that list of the products that are less than $10, we're going to `forEach` over them, and for each of those products, we're going to say `product.style.color` and we'll set that equal to red.\n```javascript\nproducts\n  .filter(product => parseFloat(product.innerHTML) < 10)\n  .forEach(product => product.style.color = 'red');\n```\nNow we're highlighting the items that are less than $10. So you can see that being able to **convert a NodeList** or any other **type of iterable** collection into an array can be very useful."},{"lesson_slug":"ecmascript-6-default-values-for-function-parameters","enhanced_transcript":"**Default arguments** in **ES6** allow you to assign some defaults to these guys. If I run this right now you'll see I'll get `undefined, undefined` because nothing was passed in for `greeting` or `names`, so when they get logged out they're both `undefined`.\n``` javascript\nfunction greet(greeting, name){\n  console.log(greeting + \", \" + name);\n}\n\ngreet();\n```\nIf I want his `name` to at least default to `John`, if I don't pass anything in, I can get `undefined` to `John`. I didn't pass anything in here, but I said the `name` should at least be `John` so it logs out the `name` as ``John``.\n\nIf I pass in `Hello` here, and then run this, you can see I get `Hello, John`. `Hello` comes through the `greeting`, logged out here as `Hello` and the `name` still defaults to `John`, and then is logged out here.\n``` javascript\nfunction greet(greeting, name = \"John\"){\n  console.log(greeting + \", \" + name);\n}\n\ngreet(\"Hello\");\n```\nIf I say `Hello, Bill`, the default will be overridden and I'll get `Bill` **instead** of `John`, because the default was `John`, but I said explicitly to say `Bill`.\n``` javascript\nfunction greet(greeting, name = \"John\"){\n  console.log(greeting + \", \" + name);\n}\n\ngreet(\"Hello\", \"Bill\");\n```\nWhere this gets a little bit crazier is when you **assign a default function** to one of the arguments. Right now, `complete` is `undefined`, so it will say `undefined is not a function` when I try to invoke it.\n``` javascript\nfunction receive(complete){\n  complete();\n}\n\nreceive();\n```\nBut, if I **pass in a function** and say `log complete`, and I run this, you can see it logs `complete` out, because it invokes it when it's passed in.\n``` javascript\nfunction receive(complete){\n  complete();\n}\n\nreceive(function(){\n  console.log(\"complete\");\n});\n```\nBut, I can take this function, I'll cut it out of here and then assign that as the default function and then I'll rerun it and you'll see I still get `complete`.\n``` javascript\nfunction receive(complete = function(){\n  console.log(\"complete\");\n}){\n  complete();\n}\n\nreceive();\n```\nWe can make this a little bit shorter using the [arrow syntax](https://egghead.io/arrow-function) that I've covered before. If I do that and then get rid of the braces and then bring everything up to the same line, you can see that I can assign a default function, all within that same line, run it again, and I still get `complete`.\n``` javascript\nfunction receive(complete = () => console.log(\"complete\")){\n  complete();\n}\n```\nIf you want to go completely crazy with arrow functions, which I don't recommend, you could go `let receive` and I'll assign it to an arrow function, delete these braces, pull everything up to the same line, and then just invoke it this way. It still runs and this just doesn't look like JavaScript.\n``` javascript\nlet receive = (complete = () => console.log(\"complete\")) => complete();\n```\nIt's not a JavaScript you'd write, but it's very unfamiliar with the new syntax, with the arrow functions and the default assignments all working on the same line."},{"lesson_slug":"ecmascript-6-destructuring-assignment","enhanced_transcript":"Typically in **JavaScript** if you have an **object** with a **property** and a **value**, and you want to log out this value, you would do some sort of **assignment**. Let's say `obj`. Then when you log it out, you would say that `obj`, and then the property name. You could run it and you would see the value in the log.\n```javascript\nvar obj = {\n  color: \"blue\"\n}\nconsole.log(obj.color); // blue\n```\n**Destructuring** allows you to do this in a little bit different way where, instead of doing this sort of assignment, I would say look up the `color` property and make that available so that I can just log out `color` and when I run this again, I'll just get `blue` again.\n```javascript\nvar {color} = {\n  color: \"blue\"\n}\nconsole.log(color); // blue\n```\nMeaning that this says find this guy and assign it to...so I have `blue` here available, and now `color` is available for me wherever I want to use it.\n\nNow this also works if I have **multiple properties** and I want to get the `color` and the `position`. I could just say `color`, then `position`. Then I can log out the `color` and the `position` and they're both available now, so I can log out `blue` and `forward`.\n```javascript\nvar {color, position} = {\n  color: \"blue\",\n  name: \"John\",\n  state: \"New York\",\n  position: \"Forward\"\n}\n\nconsole.log(color);\nconsole.log(position);\n```\nA very common scenario where you will see destructuring come into play is when you have a function which returns an object but you only want the `name` and the `state` off of that return, so I'll just say `var` and then I'll say `{name, state}`.\n```javascript\nfunction generateObj() {\n  return {\n    color: \"blue\",\n    name: \"John\",\n    state: \"New York\",\n    position: \"Forward\"\n  }\n}\nvar {name, state} = generateObj();\n```\nThen I can simply use the `name` and I can use the `state`. I can run this and I can get `John` and `New York` because name was found here, which was John, and state was found here, which was New York. Once I logged them out, I got only those things that I wanted.\n```javascript\nconsole.log(name); // John\nconsole.log(state); // New York\n```\nIf you want these named something else, you can actually just put a colon in here. I'll say `first name` and I'll say `location`. This means still look up the `name`, but instead assign it to `first name`. Look up the `state`, but instead assign it to `location`. So that when I go `first name` here and I go `location` here and I run this, I'll still get `John` and `New York`.\n```javascript\nvar {name:firstname, state:location} = generateObj();\n\nconsole.log(firstname); // John\nconsole.log(location); // New York\n```\nNow where this gets crazy, and also a little awesome, is when you have an **array** and you only want the **first item** and the **fifth item** and you don't care about the second, third or fourth. I can do the array syntax, so `var` and then assign an array.\n\nI'll say `first` and then the second item, don't care about. Third, don't care about. Fourth, don't care about. But I do want the `fifth`, and I'll just name it `first` and `fifth`. I'll log out the `first` item, then I will log out the `fifth` item.\n```javascript\nvar [first,,,,fifth] = [\"red\", \"yellow\", \"green\", \"blue\", \"orange\"]\n\nconsole.log(first); // red\nconsole.log(fifth); // orange\n```\nThen when I run this, you can see I get `red`, because `first` is assigned to `red`, and `orange`, because `fifth` is assigned to `orange`. If I wanted to start putting in second, third, fourth, I could, but right now they're not accessible, because there's just empty commas in there.\n\nFor this example we have an array of people which are just objects with some people `firstName`, `lastName`, et cetera on them. I want you to watch very carefully as we do this, because I'm going to take the people.\n\nI'll go through them with a `forEach()`, and then we'll pass on a function. I'll use the [arrow syntax](https://egghead.io/lessons/arrow-function), so that's the arrow syntax for a function, and I'm going to **destructure the parameter** that comes in. This would typically be the `person`.\n```javascript\nvar people = [\n  {\n    \"firstName\": \"Skyler\",\n    \"lastName\": \"Carroll\",\n    \"phone\": \"1-429-754-5027\",\n    \"email\": \"Cras.vehicula.alique@diamProin.ca\",\n    \"address\": \"P.O. Box 171, 1135 Feugiat St.\"\n  },\n  {\n    \"firstName\": \"Kylynn\",\n    \"lastName\": \"Madden\",\n    \"phone\": \"1-637-627-2810\",\n    \"email\": \"mollis.Duis@ante.co.uk\",\n    \"address\": \"993-6353 Aliquet, Street\"\n  },\n]\n\npeople.forEach(({firstName})=> console.log(firstName))\n```\nI'll say I only want the `firstName` off of it, so that when I log this out I can get the first name. I can run this and I can log out all of the first names of those `people`, because what happened is this function took in the **destructured version** of this, saying only give me the first name of all of these people that come in. Then I can log out just the `firstName`.\n\nLastly, to combine a couple of these concepts, if I want to get `Skyler`, I can actually use that array syntax, and I'll just say `[, \"Skyler\"]` and assign that to `people`, meaning that this is going to skip the first one, look up the second one and name it `Skyler`. Then I'll make a function which I'll call `logEmail()`, which will take a destructured of that object of just the `email property`, and we'll say log email.\n```javascript\nvar [,Skyler] = people;\n\nfunction logEmail({email}){\n  console.log(email);\n}\n\nlogEmail(Skyler) // Cras.vehicula.aliquet@diamProin.ca\n```\nThen when I say log the email of `Skyler`, and I run this, it logs out Skyler's email, which is right here, because it looks up the second item, names it `Skyler`. This is not looking up the name `Skyler`, it's just naming it `Skyler` from `people`. I'm logging Skyler's email, which is destructuring that `Skyler` object, and only taking the `email` off of it and logging out the email string, which is this."},{"lesson_slug":"ecmascript-6-es6-modules-es2015-import-and-export","enhanced_transcript":"ES6 or ES2015 introduces a standardized **module format**. I have an `index.html` file here and I've loaded it here just for the browser sync server so that we can get some live reloading. I go ahead and type this, we'll say, `With Webpack and Babel`. See that reloads. We may have an **entry point** already set up.\n\nIf I just log to the console, let's create a function here, that's going to sum two numbers and take A and B, `sumTwo(a, b)` and will just return that, `A + B`. If we want to log that out, we'll just say this, `2 + 3`. I want to take the result of this, two and three.\n```javascript\nfunction sumTwo(a,b){\n  return a + b;\n}\nconsole.log(\n  \"2 + 3\",\n  sumTwo(2,3) // 5\n);\n```\nLet's extract this `sumTwo` function now into an `addition` module. Unlike here in our `src` Directory, we'll just **create a new file**, and we'll put this within a `math` Directory, and we'll call this `addition.js`.\n\nSee that we have this `sumTwo` and we need a way of **exposing** this. That's going to look like this. We can `export`. We'll just give it the name of the function. That's going to expose the `sumTwo` function when we **import** the module. \n### math/addition.js\n```javascript\nfunction sumTwo(a,b){\n  return a + b;\n}\n\nexport { sumTwo }\n```\nWhat that looks like, we can say, import. We'll just `import { sumTwo } from`...if we look at our directory structure, we had had the `math/addition` Expand that.\n### main.js\n```javascript\nimport { sumTwo } from `math/addition`;\n```\nNow, let's add another function to the `addition` Module. We will add three numbers together, two plus three plus four. We'll just create this. We'll call this `sumThree()`.\n### main.js\n```javascript\nconsole.log(\n  \"2 + 3 + 4\",\n  sumThree(2, 3, 4)\n);\n```\nNow, we're going to import that the same way. We'll add it to this list here, `sumThree`. Now, let's just define that. Now, let's export that. Add it to our Exports, `sumThree`.\n### math/addition.js\n```javascript\nfunction sumThree(a, b, c){\n  return a + b + c;\n}\n\nexport { sumTwo, sumThree }\n```\nWe can see over here that we are importing that successfully. Now, there's a few variations of how we can accomplish both importing and our exporting. Let's take a look at maybe how we can **export** this little differently. You can actually export directly on a **Function Definition** like this. We can just say, `Export, Export`. I'm going to drop this and we're still reloading just the same.\n### math/addition.js\n```javascript\nexport function sumTwo(a, b) { ... }\n\nexport function sumThree(a, b, c) { ... }\n```\nThere's a few different ways that we can import these. Let's take a look at a few. We give this a little more breathing room. We can give each of our **import statements an alias**.\n\nWe can `import sumTwo as addTwoNumbers`. If we run this, we'll see that `sumTwo` is not `defined`. If we update this to use our alias, `addTwoNumbers`.\n### main.js\n```javascript\nimport {\n  sumTwo as addTwoNumbers,\n  sumThree\n} from 'math/addition';\n```\nNow, let's import the module as a whole. We'll just copy this path here and we'll say, `Import * as addition from` our path. We'll drop this import statement and we just need to make a few updates here, this is going to be called `sumTwo`.\n\nSince we're importing the module as a whole `as addition`, these are going to be on the `addition` object. Let's update these numbers just so we can see a little more change on that side.\n### main.js\n```javascript\nimport * as addition from 'math/addition';\n\nconsole.log(\n  \"1 + 3\",\n  addition.sumTwo(1, 3) // 4\n);\n\nconsole.log(\n  \"1 + 3 + 4\",\n  addition.sumTwo(1, 3, 4) // 8\n);\n```\nWe've seen how we can **define and import** our own custom modules. Let's import a third party package. Let's create a module for some dummy user data. I'm going to just call this `data/users.js`\n\nI'm pasting this array of users that I have here. We'll make sure that we export that. \n### data/users.js\n```javascript\nvar users = [\n  { 'user': 'barney', 'age': 36, 'active': false, 'pets': ['hoppy']},\n  { 'user': 'fred', 'age': 40, 'active': true, 'pets': ['baby puss', 'dino'] }\n];\n```\nWe'll head over here and we will `import users from  'data/users'` Module. Let's log that out and let's make sure that everything looks OK.\n\nWe have our object over here of our `users`. We drop each of those down. Let's pull `lodash` in and make use of the Where function that it provides us. `npm install --save lodash`. While that's installing, we'll go ahead and we'll just `import * as _ from 'lodash';`.\n### main.js\n```javascript\nimport * as _ from 'lodash';\n\nimport {users} from 'data/users';\n```\nNow, we go to the alias, the `underscore` from `lodash`. We're going to be using the `_.where` method. Let's go ahead and use that `_.where(users, {age: 36})`. What we're going to be looking for is we want to grab at the age of `36`. We should just get `Barney` back.\n### main.js\n```javascript\nconsole.log(_.where(users, {age: 36}));\n```\nFor the age is `36`. If you look at our results here, we got one `user` back with the name of `Barney`. I've covered a few usages of importing and a few different styles of importing and using aliases, exporting. We thought we can **export our functions directly**.\n\nIf you're looking for more information, head over to [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export), or [Babel](https://babeljs.io/docs/learn-es2015/) has some pretty good summaries of the **ES6 modules syntax**."},{"lesson_slug":"ecmascript-6-generators","enhanced_transcript":"You make a **generator** by adding **asterisks** right here after the **function** keyword. I'll go ahead and add a log statement saying that `You called 'next()'`. You might think that if I called `greet()` that it would log out `You called 'next()'` but nothing happens.\n```javascript\nfunction* greet(){\n  console.log(`You called 'next()'`);\n}\n\ngreet();\n```\nIf we assign something like a `greeter` to this `greet()` and then we see what the `greeter` is you can see that the `greeter` is actually an **object** so it did not invoke this. It actually created an object which I can call `next()` on. When I call`greeter.next()`, and I'll just call this next and log that out. You can see that next is `{value: undefined, done: true}`.\n```javascript\nlet greeter = greet();\nconsole.log(greeter); // { next: [Function], throw: [Function] }\nlet next = greeter.next();\nconsole.log(next);  // You called 'next()'\n                    // { value: undefined, done: true }\n```\nYou can also see that it finally invoked our log statement saying that `You called next()`. Now, this is `undefined` because we didn't **yield** anything from our generator. It's `done` because it's gone through all of the yield statements which are actually **none** right now.\n\nIf I yield a simple `hello` and run this again you can see now I get `{value: hello, done: false}`. It logged out our statement. It returned `hello` and it's not done yet. It will actually be done on the next pass through next.\n```javascript\nfunction* greet() {\n  console.log(`You called 'next()'`);\n  yield \"hello\";\n}\n\nlet greeter = greet();\nconsole.log(greeter); // { next: [Function], throw: [Function] }\nlet next = greeter.next();\nconsole.log(next);  // You called 'next()'\n                    // { value: 'hello', done: false }\n```\nIf I call `next()` again, and I'll just name this one `done`, and I call the log statement again, so I'll just log out `done`. You can see that I get `hello` on the **first pass** with `done: false` and undefined with `done: true` because there are no more yield statements after this one, meaning it had iterated and gone through all of the yield statements.\n```javascript\nlet greeter = greet();\nconsole.log(greeter);       // { next: [Function], throw: [Function] } \nlet next = greeter.next(); \nconsole.log(next);          // You called 'next()'\n                            // { value: 'hello', done: false }\nlet done = greeter.next();\nconsole.log(done);          // { value: undefined, done: true }\n```\nIf you have **multiple yield statements** like `How`, `are`, and `you` and you run this with only calling `next()` once you can see that it **stops** after calling `how`. This, `console.log('I'm not called until the second next')`, is not called. That, `console.log('Call me before \"you?\"');` not called, and that, `console.log('Called when \"done\"');`  not called.\n```javascript\nfunction* greet(){\n  console.log(`Generators are \"lazy\"`);\n  yield \"How\";\n  console.log(`I'm not called until the second next`);\n  yield \"are\";\n  console.log(`Call me before \"you?\"`);\n  yeild \"you?\";\n  console.log(`Called when \"done\"`);\n\n  var greeter = greet();\n  console.log(greeter.next()); // Generators are \"lazy\"\n                               // { value: \"How\", done: false }\n}\n```\nIf you were to create any objects or anything inside of here they would not be created until you called `next()`, meaning that you can **put stuff** in here that's **not created until you explicitly need it**.\n\nIf we go ahead and call `next()` three more times and run it again you can see it logs out each log statement, then the yield, the log, then the yield. It logs this, then yields that, then logs this, then yields the next one.\n\nBecause it's an iterator you can also use the for/of syntax. We can say `for(let word of greeter)` and then log out the word and then run that. You can see the output is basically the same. `How are you?` The main difference is that this is grabbing the value off of the next.\n```javascript\nfor(let word of greeter) {\n  console.log(word);  // Generators are \"lazy\"\n                      // How  \n                      // I'm not called until the second next\n                      // are\n                      // Call me before \"you?\"\n                      // you?\n                      // Called when \"done\"\n}\n```\nTo do that by calling next we'd have to revert this and say `.value`, then run it again and we get the same output.\n```javascript\nconsole.log(greeter.next().value); // Generators are \"lazy\"\n                                   // How\nconsole.log(greeter.next().value); // I'm not called until the second next\n                                   // are\nconsole.log(greeter.next().value); // Call me before \"you?\"\n                                   // you?\nconsole.log(greeter.next().value); // Called when \"done\"\n```\nIt's really easy to get mixed up when you start assigning things to yield statements. If I say `let friendly = yield \"how\";` and then I try to log out `friendly` you might expect it to log out `how` because that's what it's yielding. But if I run this you'll see it's actually logging out `undefined`.\n\nThe way that this works is that the `next()` step through the iteration, so if I say `\" The heck\" `, will basically send this back through and assign it to this `friendly`. If I log this out now you'll see I get `How`, and then `The heck`. That means you can start building things through the **iteration process**.\n```javascript\nfunction* greet(){\n  let friendly = yield \"How\";\n  yield \"are\";\n  yield \"you?\";\n}\n\nvar greeter = greet();\nconsole.log(greeter.next().value);              // How\nconsole.log(greeter.next(\" the heck \").value);  //  the heck\nconsole.log(greeter.next().value);              // are\n                                                // you?\n```\nIf I yield `friendly + are` and then I assign `friendly` to this and then I yield `friendly + \"you\"` and I pass in `\" silly ole \"` and I run this again you can get `How the heck are silly ole you?` because this message is being returned here when the next step is run and assigned to this `friendly`. I yield that part of the `friendly` and then this comes from here, which is being assigned here. Then it yields that final statement.\n```javascript\nfunction* greet(){\n  let friendly = yield \"How\";\n  friendly =  yield friendly + \"are\";\n  yield friendly + \"you?\";\n}\n\nvar greeter = greet();\nconsole.log(greeter.next().value);              // How\nconsole.log(greeter.next(\" the heck \").value);  //  the heck are\nconsole.log(greeter.next(\" silly ol`\").value);  //  silly ol'you?\n```\nOne thing to note is that because this **assignment** happens on the **run after** the **first** one it's actually impossible to **pass a value** in here. \n```javascript\nvar greeter = greet();\nconsole.log(greeter.next(\"first\").value); // TypeError: Sent value to newborn generator\n```\nIf I try and say `\"first\"` and run this I'll get an error saying, `Sent value to a newborn generator`, because you haven't given this a chance to run and iterate and go to the `next()` step where you could actually pass in a value.\n\nLastly, generators also help you work with **infinite sequences**. If I wrap my yield with a `while(true)`, which is never going to stop looping, I can safely `yield {x:x, y:y}` point knowing confidently that this stuff isn't going to evaluate until the next step through after the yield process.\n```javascript\nfunction* graph(){\n  let x = 0;\n  let y = 0;\n  while(true){\n    yield  {x:x, y:y}\n    x += 2;\n    y += 1; \n  }\n}\n\nvar graphGenerator = graph();\nconsole.log(graphGenerator.next().value);\n```\nIt will safely pause instead of infinitely going through this while loop. When I run this, you can see I get zero, two, four, six, eight and so on. Zero, one, two, three, four, and so on. \n```javascript\n// {x: 0, y: 0}\n// {x: 2, y: 1}\n// {x: 4, y: 2}\n// {x: 6, y: 3}\n// {x: 8, y: 4}\n// {x: 10, y: 5}\n// {x: 12, y: 6}\n// {x: 14, y: 7}\n```\nI could generate these forever. They're also only created when I request them through the yield. They're not created ahead of time.\n\nDon't worry. We will dive more into practical use cases of **generators** in future videos."},{"lesson_slug":"ecmascript-6-maps-and-weakmaps-with-es6","enhanced_transcript":"Today we're going to do an introductory overview of **maps** and **weakMaps** with **ECMAScript 2015** or **ES6**. The map object is just a simple **key value map**. JavaScript objects and maps are very similar to each other, and before the introduction of maps in ES6, objects were used in order to keep track of different key value pairs.\n\nHowever, maps does offer us a few bonuses that we don't get from **objects**. For example, an object has a **prototype**, so by default, there are keys in the map whether the user has added them or not. Secondly, an **object key has to be a string**, whereas in a map, it can be **anything** from a **function, to an object**, to **all** other types of **primitives**.\n\nLastly, maps have **methods** on them that allow you to **easily get the size** of and **keep track of the size** of your map, whereas to objects, there's no innate method that allows you to quickly get those answers.\n\nThe first thing that we want to do is inside of our JSBin, just go ahead and make a map. We'll just do, `var myMap = new Map()`. Next, let's list out the **API** that we'll be going over in this tutorial. We have the `set()` method and then the `get()` method, followed by the `size` property, as well as the `clear()` and `has()` method.\n```javascript\nvar myMap = new Map();\n\n// API\n/*\nset()\nget()\nsize\nclear()\nhas()\n*/\n```\nFirst thing we want to do is go ahead and **set** some key value pairs on our new map. To do that, we'll take advantage of the `set()` method. We'll just do `myMap.set()` with a key of `foo` and a value of `bar` followed `myMap.set()` with a key of `hello` followed by a value of `world`.\n```javascript\nmyMap.set('foo', 'bar');\nmyMap.set('hello', 'world');\n```\nTo get an idea of what the get method does, let's go ahead and just `console.log` out `myMap.get(foo)`. If we come over to our console and we run this, we'll notice that `bar` is returned. That's because that is the **value associated with** the `foo` key inside of our map. If we attempt to access a value that does not exist, we'll get `undefined` back.\n```javascript\nconsole.log(myMap.get('foo'));\n```\nNext, let's go ahead and look at the size property that we have available to us. If we `console.log(myMap.size())` and go ahead and run the console again, we'll see that `2` is returned to us because we have two items inside of our map.\n\nThe clear method is quite self-explanatory. If we go ahead and insert a `myMap.clear()` above the console.log, we'll see when we run the output, we get zero back, because there's no longer any items in our map.\n```javascript\nmyMap.set('foo', 'bar');\nmyMap.set('hello', 'world');\n\nmyMap.clear();\n\nconsole.log(myMap.size); // 0\n```\nNext, Let's look at the `has()` method available to us through the map API. If you go ahead and write `has()` with an argument of foo, we'll see that true is returned back. If we insert a key that does not exist, such as qwerty, and go ahead and run that, we'll see that false is returned back.\n```javascript\nconsole.log(myMap.has('foo')) // true\n\nconsole.log(myMap.has('qwerty')) // false\n```\nMap gives us several **iterators** that we can use to go over our map to **access** the keys, values, and entries. Those are the **keys** method, the **entries** method, and the **values** method. To get an idea of what that looks like, let's go ahead and create a **for-of** loop in here, and we'll do `for(var key of = myMap.keys()`, and we'll console.log out each key.\n```javascript\nfor(var key of = myMap.keys(){\n  console.log(key)\n  // \"foo\"\n  // \"hello\"\n}\n```\nIf we clear the console and run it again, we'll see that we get `foo` and `hello` returned to us, because those are the two keys inside of our map.\n\nAlternatively, we can go ahead and do a for-of loop for the values inside of our map. Let's go ahead and switch the variables so it makes a little more sense, and we'll console.log that out. We'll see that `bar` and `world` is returned to use, because those are the values that are stored within our map.\n```javascript\nfor(var key of = myMap.values(){\n  console.log(value)\n  // \"bar\"\n  // \"world\"\n}\n```\nLastly, we can iterate over the entries. What the entries does is it **returns to us an array made of arrays** where the first item in the array is the key and the second item is the value. If we do `for(var [key, value] of myMap.entries())` and console.log that out, we'll see that we get `foo = bar` and `hello = world.`\n```javascript\nfor([key, value] of myMap.entries()){\n  console.log(key + ' = ' + value);\n  // \"foo = bar\"\n  // \"hello = world\"\n}\n\n```\nNext, I wanted to quickly go over **weakMaps** in ES6. What a weakMap means is that **no references are held to the keys of the map**. With no references being held to the keys of the map, it allows it to be available for **automatic garbage collection** that's available to us in JavaScript.\n\nBecause no references are kept to the keys, that means that they are **innumerable**, or we cannot iterate over them. Because of this, the options of what is available for us to use as keys in our map is limited when using weakMaps.\n\nFor example, with a map, we can use anything as its key. To show that, let's create `var myObject`, set it equal to an empty object. `var myFunction`, set it equal to an anonymous function.\n```javascript\nvar myObj = {};\nvar myFunc = function(){};\n```\nNow, in our set methods, we can swap out `foo` and `hello` for `myObject` and `myFunction`. We can run our output and see that the entries method shows us that we have our object and our function as the keys for var and world.\n```javascript\nmyMap.set(myObj, 'bar');\nmyMap.set(myFunc, 'world');\n  // \"[object Object] = bar\"\n  // \"function myFunc() {} = world\"\n```\nThe important thing to note is that we can also **use strings** for our keys. We can say set string with a value of two. We can run our output again, and we'll see that string two is given back to us as a key value store.\n```javascript\nmyMap.set('string', 2);\n  // \"string = 2\"\n```\nIf we go up here, and we change var myMap to a weakMap, and we run this again, we'll see that we get some errors.\n\n![Invalid Value](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-maps-and-weakmaps-with-es6-invalid-value.png) \n\nThe first thing we get is that we cannot use a string as a key in our weakMap. If we go ahead and get rid of that string and run the output again, we'll see that we get a new error.\n\n![Entries not a Function](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-maps-and-weakmaps-with-es6-entries-not-function.png)\n\nThis time, we see that entries is not a function. Because of the enumerable nature of our weakMaps, that means that all of these iterator API methods available to us on the map is no longer available on the weakMap."},{"lesson_slug":"ecmascript-6-object-enhancements-in-es6","enhanced_transcript":"**ES6** comes with some **object enhancements**. If I want to create a `car` with that `color` and `speed`, I can just say `{color, speed}` and then log out `car.color` and `car.speed`. When I run this, you can see I get `red` and `10`.\n``` javascript\nvar color = \"red\";\nvar speed = 10;\n\nvar car = {color, speed};\n\nconsole.log(car.color); // \"red\"\nconsole.log(car.speed); // 10\n```\nThat's because if you **declare a property** with the exact **same name** as something, it'll treat it just as if you did `color:color` and `speed:speed`. This is the **ES5** way, and this is the ES6 way.\n``` javascript\n// ES6\nvar car = {color, speed}\n\n// ES5\nvar car = {color:color, speed:speed};\n```\nThis even works for functions. If I create a function called `go` and say `vroom`, I can simply add another property here, call it `go`, and then say, `car.go()`. Then I'll run this. You can see it says, `vroom`.\n``` javascript\nvar color = \"red\";\nvar speed = 10;\nfunction go() {\n  console.log(\"vroom\");\n}\n\nvar car = {color, speed, go};\n\ncar.go(); // \"vroom\"\n```\nAnother cool thing...I'm going to format this just a little bit, put these on new lines...is that instead of using the function keyword, I can actually cut and paste this here. Then I'll just delete that. This is valid syntax for declaring a function on an object. If I save and run again, you'll see I get the same result. \n``` javascript\n// ES6\nvar car = {\n  color,\n  speed,\n  go(){\n    console.log(\"vroom\");\n  }\n};\n```\nThis is the ES6 way, and that's the ES5 way. It's basically a **shorthand** that saves you some typing.\n``` javascript\n// ES5\nvar car = {\n  color,\n  speed,\n  go: function(){\n    console.log(\"vroom\");\n  }\n};\n```\nThe last fun trick to show you is that if you type something like this, you can actually have a **computed property** where it'll evaluate this. This is pretty much just like if you were to do `car[\"go\"]` like that, but now you're doing it inline inside of an object declaration.\n``` javascript\nvar car = {\n  color,\n  speed,\n  [\"go\"]: function(){\n    console.log(\"vroom\");\n  }\n};\n```\nThis will still work when I run it. I ran it and got `vroom` still. I can actually extract this `go`. I'll cut that out, say `var drive`, paste it in there. Then we can put `drive` in here, hit save, run it. We still get `vroom`.\n``` javascript\nvar drive = \"go\";\nvar car = {\n  color,\n  speed,\n  [drive]: function(){\n    console.log(\"vroom\");\n  }\n};\n```\nYou could do any sort of **string concatenation** or evaluation in there to generate some sort of **string**, which would **evaluate** into the **name** of something that you could then **call** later on."},{"lesson_slug":"ecmascript-6-promises-with-es6","enhanced_transcript":"In today's lesson, I want to go over **promises** with **ES6** or **ECMAScript 2015**. Promises in ES6 are very similar to those of **Angular's $q service**, if you're familiar with that framework.\n\nFirst thing I want to do before we start explaining what promises is and how to use them is just build out a basic skeleton that we can add to throughout the video.\n\nTo get started, we'll go ahead and create a new variable, which we'll just call `d`, and we'll set that equal to a `new Promise()`. The **callback** inside of a promise takes two arguments, **resolve** and **reject**. You'll notice that we're using the [ES6 arrow function syntax](https://egghead.io/lessons/arrow-function) throughout this project.\n```javascript\nvar d = new Promise((resolve, reject) => {\n\n});\n\nd.then();\n\nd.catch();\n```\nPromises can either be resolved or rejected. When you resolve a promise, the `.then()` will fire, and when you reject a promise, the `.catch()` will fire instead. Usually, inside of your promise, you have some sort of **logic that decides** whether you're going to **reject or resolve the promise**.\n```javascript\nvar d = new Promise((resolve, reject) => {\n  if (true) {\n    resolve('hello world');\n  } else {\n    reject('no bueno');\n  }\n});\n```\nLet's go ahead and build the basic **if-else** statement here. Inside the i- statement, we'll go ahead and resolve the promise. We'll pass in a string of `Hello world`. Inside the else statement, let's reject the promise, and we'll just pass in a string of, `No bueno`.\n\nNow, because we're just evaluating the **Boolean** `true` inside this if-statement, we know that our resolve is going to fire. To get an idea of what this is going to look like, let's go down to our `d.then()`.\n\nThe `.then()` method callback also takes an argument. This one we'll call `data`. The value for data is the argument that is passed into the resolve method. In here, let's just go ahead and `console.log`, and we'll say `success`, and we'll print out our data.\n```javascript\nd.then((data) => console.log('success : ', data));\n```\nAlternatively, in the `.catch()` method, we also have a callback function as the argument, but here, what will be passed back is the information that's supplied into the reject method of our promise. Why don't we just go ahead and `console.error`, and here we'll say, `Error`, and we'll spit out that error data that's supplied back to us.\n```javascript\nd.catch((error) => console.error('error : ', error));\n```\nIf we come back into our console and we run this logic, we'll notice that, `Success : Hello world`, is returned to us, because that's what we have specified in the callback of our `.then()` method.\n\nIf we go up to our promise and we change this `true` to `false`, we'll cause our `reject()` to fire off, and, `No bueno`, will be passed through instead. So, let's come back to our console and run it again. We notice we get our `error : No bueno`.\n\nPromises are useful for a lot of things. Most importantly, they allow you to perform **asynchronous operations** in a **synchronous-like** manner.\n\nTo get an idea of what this asynchronous behavior would look like, let's go ahead and create a `timeout`. Inside of the `timeout`, we'll create a function, and in this function, let's just put our if-else statement that we were using previously. Let's set a timeout here of two seconds.\n```javascript\nvar d = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    if (false) {\n      resolve('hello world');\n    } else {\n      reject('no bueno');\n    }\n  }, 2000);\n});\n```\nWe still have our `false` being evaluated by the if statement, so after a two-second delay, we should see that our, `Error : No bueno`, is passed into our console. Let's come back down here and run it again. We have a two-second delay where, `Error : No bueno`, is returned to us.\n\nWe can go ahead and change this to `true`, run it again, and this time we'll see that we get, `Success : Hello world`, after our two-second delay.\n\nThere's several different methods you can use when dealing with your `.then()` and `.catch()` callbacks. If you don't prefer to use the `.catch()` method, you could then, instead, supply a second argument into the `.then()` method, which will act as an **error** callback.\n\nIn here, let's go ahead and pass in our `error` again as our parameter, and we'll just `console.error`. This time, we'll do a new message so that we can see that it's actually our second callback of the `.then()` method which is being called.\n```javascript\nd.then ((data) => console.log('success : ', data), (error) => {\n  console.error('new error msg: ', error);\n});\n```\nLet's go back up to our `if` statement, change `true` to `false` so we can make sure that our reject is what's fired. We'll come back down into our console. We'll run the code. Again, after our two-second delay, we'll see that the new error message, `No bueno`, is returned to us.\n\nI prefer to use the `.catch()` method for rejects and `.then()` for resolve only. This ensures that I can always be certain that if I have a function inside of the `.then()` method, that it is my **success callback**, and I can put in the appropriate code.\n\n`.then()` and `.catch()` can also be **chained together**. Let's go ahead and chain these two things together, run our code again, and we'll notice that we still get our **error message**.\n```javascript\nd.then((data) => console.log('success : ', data)).\n  catch((error) => console.error('error : ', error));\n```\nAlternatively, we can decide to chain several .thens together and have them called in succession. We'll notice now, if we change our if-statement to `true` and run our code, the resolve will be called and both .thens will **fire one after another**. Let's come down and run our code.\n```javascript\nd.then((data) => console.log('success : ', data)).\n  then((data) => console.log('success 2 : ', data)).\n  catch((error) => console.error('error : ', error));\n```\nWe see that we get `success` and `success 2`. Notice that `success 2` is `undefined`. This is because the `data` that's available in the **callback** of the second then is not what is **originally passed** into the **resolve** but rather what is **returned from the original .then method**.\n\nTo see a working example of this, let's go ahead and return a value from our first `.then()`, which will then be **passed into the second** `.then()`. If we come back to our console and run the code again, we'll notice that rather than `undefined`, we get `foo bar` passed back to us.\n```javascript\nd.then((data) => {\n    console.log('success : ', data);\n    return 'foo bar';\n  }).\n  then((data) => console.log('success 2 : ', data)).\n  catch((error) => console.error('error : ', error));\n```\nOne more important thing to note is that whenever an **error or exception** is thrown within the **promise**, it will automatically trigger the `.catch()` to call, **regardless of when that error's thrown**.\n\nTo see a basic example of this, let's go ahead and throw a new `error`, run our code again, and we'll notice that this time our `error` is returned to us, even though we're **evaluating true**, which means our **resolve should fire**. This statement remains `true`, regardless of when the **error's thrown throughout the promise**.\n```javascript\nvar d = new Promise((resolve, reject) => {\n  throw new Error('error thrown!');\n  setTimeout(() => {\n    if (true) {\n      resolve('hello world');\n    } else {\n      reject('no bueno');\n    }\n  }, 2000);\n});\n```\nFor example, if we come into our second `.then()` statement, we can go ahead and throw that error in the second `.then()`, and we'll notice that the **catch will also fire**.\n\nNow, if we were to add that error to the first `.then()`, then that **second then would never fire**, because it's going to go straight to the catch.\n\nThose are some basic examples of how to use promises with ES6 or ECMAScript 2015."},{"lesson_slug":"ecmascript-6-shorthand-properties-in-es6","enhanced_transcript":"Where [destructuring](https://egghead.io/lessons/ecmascript-6-destructuring-assignment?course=learn-es6-ecmascript-2015) in **ES6** allows you to easily get **properties out** of an object, this **shorthand property** syntax allows you to easily **push properties in**. It's like destructuring backwards.\n\nIf I have a `firstName` and a `lastName` and I want to create a `person`, I can just say, `{firstName, lastName}`. Then when I log out my `person` and I run this, you can see that it logs out an object with the first name of `John` and a last name of `Lindquist`.\n``` javascript\nlet firstName = \"John\";\nlet lastName = \"Lindquist\";\n\nlet person = {firstName, lastName}\n\nconsole.log(person);\n```\nIf I wanted to build some more objects, like I want to build a `team`. I have a `mascot` with a `Moose`, and I wanted to build a `team` like this, where I have a `person` and a `mascot`, and then I log out my `team`. I have a `team` object with a `person` of `{firstName, lastName}`, `John` and `Lindquist`, with the `mascot` of `Moose`.\n``` javascript\nlet mascot = \"Moose\";\nlet team = {person, mascot};\n\nconsole.log(team);\n```\nThis syntax allows you to easily **construct objects** with the **properties** and things you already have and just build them up however you'd like."},{"lesson_slug":"ecmascript-6-string-templates","enhanced_transcript":"If you have ever worked with **strings** in **JavaScript**, you've most likely **concatenated** two strings by just saying the variable then plus and then adding a string to it, and then when you run it, you just get `Hello, World`, all put together.\n```javascript\nvar salutation = \"Hello\";\nvar greeting = salutation + \", World\";\n\nconsole.log(greeting);\n```\n**ES6** allows you to put your **variables inside of your string**. I'm going to surround this with a **grave**. So I'll put one there and I'll put one here.\n\nThen, instead of doing plus and then quote, I'll just surround this guy with the dollar sign, curly brace, and then close curly brace. You'll see if I rerun this, I'll get `Hello , World`.\n```javascript\nvar greeting = `${salutation} , World`;\n```\nIt actually **maintained this space** because I forgot to delete it. So if I delete that and run it again, then we'll get `Hello, World` without the space.\n```javascript\nvar greeting = `${salutation}, World`;\n```\nIt actually **respects white space** even across **multiple lines**. If I put some lines in here and if I say `hello, tab, tab, world`, and run this. You'll see I get some blank lines, hello all the way at the left and then a couple tabs, and then world, and then more blank lines.\n```javascript\nvar greeting = `\n\n${salutation}, \n\n    World\n    \n    \n`;\n```\n\n![String Templates Respect Whitespace](https://d2eip9sf3oo6c2.cloudfront.net/asciicasts/learn-es6-ecmascript-2015/ecmascript-6-string-templates-maintains-whitespace.png)\n\nI could pull off things like `hello you crazy world, how are you`, and rerun this and you can see, we can **manipulate strings** however we'd like.\n```javascript\nvar greeting = `\n\n${salutation}, \n  You\n    Crazy       World\n\n    How\n  Are\n      You  \n    \n`;\n```\nIf I want to extract any of these into variables, I could just instead of `World` here, I could just do `place` and then I can do `place`. We'll just say `planet`, and rerun this, and you can see we get `hello, you crazy planet`, all the way out here.\n```javascript\nvar place = \"planet\";\nvar greeting = `\n\n${salutation}, \n  You\n    Crazy       ${place}\n\n    How\n  Are\n      You  \n    \n`;\n```\nIt's also worth noting that you can do **expressions** inside of these braces. If you want to do `X + Y`, then just show `Y` and just show `X`, and then run this. You can see we get `1 + 2 = 3`, and then this is one.\n```javascript\nvar x = 1;\nvar y = 2;\nvar equation = `${ x } + ${ y } = ${x + y}`\n\nconsole.log(equation); // \"1 + 2 = 3\"\n```\nThere's this string plus, there's two, there's the string equals, and then `X + Y` is the expression.\n\nLastly, is a basic introduction to **tagging** these **string templates** that I have. `It's` and then the hour of the day,`${new Date().getHours()}`, and then, `I'm sleepy`. If I run this, you'll see it's `15` or 3 o'clock, and that `I'm sleepy`.\n```javascript\nvar message = `Its ${new Date().getHours()} Im sleepy`;\n\nconsole.log(message); // \"It's 15 I'm sleepy\"\n```\nI don't get sleepy until after 20, so all I have here is this and how am I going to make this into a variable? Well, I can actually **parse** out this `message` and get this value and **change this string** based on this **value**.\n\nI'm going to create a function called, `tag()`, and notice I don't put any sort of **parameters** or anything around this. I just type the **function name**.\n```javascript\nvar message = tag`Its ${new Date().getHours()} Im sleepy`;\n```\nI'll say, `function tag`, you can name it whatever you want, `tag` or `parse`, or whatever, and then it takes these `strings` and the `...values`, these `strings` being an **array**.\n```javascript\nfunction tag(strings, ...values){\n  console.log(strings); // [ 'It\\'s', 'I\\'m sleepy' ]\n  console.log(values);  // [ 15 ]\n}\n```\nWe'll log this out. The **array** of `It's` and `I'm sleepy` are the two **strings**. This piece and this piece, and then the values are the values found in here.\n\nWhen I log this out, this will be an **array** with just `15` in it. So switch this over to a value. We'll just make it an empty value, `${}`.\n```javascript\nvar message = tag`Its ${new Date().getHours()} Im ${\"\"}`;\n```\nThen, we'll say, if the `first value`, so value `0 < 20`. I'll assign the `second value` and say this should be `I'm awake`.\n```javascript\nfunction tag(strings, ...values){\n  if(values[0] < 20){\n    values[1] = \"awake\";\n  }\n}\n```\nThen, we will turn a new `string`. So two `back ticks`, and we'll just say, `` return `${strings[0]}${values[0]}${strings[1]}${values[1]}` ``\n\nThen, once we log this out, you can see it says, `It's 15, I'm awake`, because `15` is less than `20` and we assign this second value which is this guy to `awake`.\n\nNow, there's much more advanced stuff you can do with this such as **parsing HTML** and using **RegEx** and everything, but we're going to end right there for right now."},{"lesson_slug":"ecmascript-6-using-the-es6-spread-operator","enhanced_transcript":"The **spread operator** allows you to take an array and spread it out into its **individual items**. If I log out an array with `[ 1, 2, 3]` you can see I get an array, so you have the brackets with `[ 1, 2, 3]`.\n```javascript\nconsole.log([ 1, 2, 3]); // [1, 2, 3]\n```\nIf I put the three dots in front to say I want to spread this array and I hit run again, you can see I get `1, 2, 3` with no brackets around it. \n```javascript\nconsole.log(...[ 1, 2, 3]) // 1 2 3\n```\nThis actually allows us to **push elements** easily into other **arrays**. Before if I were to do `first.push(second)` and log this out, you'll see, I'll get one two three and then **another array inside of my array**, `[ 1, 2, 3, [ 4, 5, 6] ]`.\n```javascript\nlet first = [ 1, 2, 3];\nlet second = [ 1, 2, 3];\n\nfirst.push(second);\n\nconsole.log(first); // [ 1, 2, 3, [ 4, 5, 6] ]\n```\nBut instead, if I spread out the second array and push that in, you can see I get the individual items pushed in. \n```javascript\nfirst.push(...second);\n\nconsole.log(first); // [1, 2, 3, 4, 5, 6]\n```\nI could actually duplicate that and save and you can see I get `[ 1, 2, 3, 4, 5, 6, 4, 5, 6]`. So I'm pushing in the individual items over and over instead of pushing in arrays.\n\nThis even works for doing things like pushing in an **array of parameters**. If I want to `addThreeThings` and then push in my `first` collection there, hit run, you can see I get `six`, which is one plus two plus three. \n```javascript\nfunction addThreeThings( a, b, c){\n  let result = a + b + c;\n  console.log(result); // 6\n}\n\naddThreeThings(...first);\n```\nI just passed in first and then I spread it out into one, two, and three and I can do the same thing for second and run this and you'll see I'll get `6` and `15`. 15 being 4 plus 5 plus 6, which is 4 plus 5 plus 6. Because, again, this, these **three dots**, are **spreading the array** out into its individual elements."},{"lesson_slug":"javascript-es6-rest-parameters","enhanced_transcript":"In this video we're going to talk about **ES6 rest parameters**, verse the **arguments keyword** in ES5. What the arguments keyword does is return back to us an **array like object** of all the arguments that we're passing to our function. To see a simple example of this, let's go ahead and create `myfunc()`, and just console log out the `arguments` keyword of that function. Down below we'll call `myfunc` with arguments one, two, three, and run that to see what the console output is.\n```javascript\nfunction myFunc() {\n  console.log(arguments);\n}\n\nmyFunc(1, 2, 3)\n//[object Arguments] {\n//  0: 1,\n//  1: 2,\n//  2: 3\n//}\n```\nAs you can see, we're returned back an array like object with all of the arguments that were passed into the function. Because it is array like, there's certain **properties** that are available to us on the arguments keyword that are also available to us on an array.\n\nFor example, in our console log, let's go ahead and add the `.length`. Run the function again, and we'll see that `3`, the length of our array like arguments, is returned back to us. It's important to note that most methods available to us on arrays are not available to us on the arguments keyword.\n```javascript\nfunction myFunc() {\n  console.log(arguments.length); // 3\n}\n\nmyFunc(1, 2, 3);\n```\nFor example, let's do a `forEach()` on the arguments. In our callback function, we have our `value`, `index`, and `array` parameters. Let's just console log out the value for each loop. If we run this again, we'll see that `arguments.forEach()` is not a function. That's because while arguments is array like, it **does not have all of the methods that the array prototype has** on it.\n```javascript\nfunction myFunc() {\n  arguments.forEach(function(v, i, a){\n    console.log(v); // TypeError: arguments.forEach is not a function\n  })\n}\n\nmyFunc(1, 2, 3);\n```\nTo show an example of how we worked around this in **ES5**, and how rest parameters mean that we don't have to anymore, let's create a new **constructor**. We'll call this constructor `store`, and in it we'll return an object with some methods.\n\nThe first one will be the add method, and what this will do is add new items to something inside of our store. Let's create `var isle`, and we'll have some categories like `fruit` and `vegetable` which have arrays of all the fruits and vegetables in that `aisle`.\n```javascript\nfunction Store() {\n  var aisle = {\n    fruit: [],\n    vegetable: []\n  }\n  return {\n    //Store().add('category', 'item1', 'item2');\n    add: function(category) {\n\n    },\n    aisle: aisle\n  }\n}\n```\nLet's return that back to us as well, so we can access it from outside the constructor, and inside of our `add` method we'll have a function that takes this specific `aisle` as the first parameter, and then all the items we're adding to that aisle as the remaining parameters.\n\nIn the past, with ES5 the way that we turned our array like arguments into an actual array was to use the **splice call hack**. The way we did this was we called splice on an array, and then we called it with our arguments, starting with the first index. What this does is exclude the `category` argument, but takes the remaining arguments, and puts them into an array that we've called items. If we console log out items in this function, we can see the array that's created.\n```javascript\nreturn {\n   //Store().add('category', 'item1', 'item2');\n    add: function(category) {\n      var items = [].splice.call(arguments, 1);\n      console.log(items);\n    },\n}\n```\nLet's create a new instance of this constructor, and we'll call it `myGroceryStore`. Down below we'll call `myGroceryStore.add()`, and we'll be adding to the fruit aisle apples and oranges. If we clear out our console, and run this again, we'll see that apples and oranges are the fruits inside the items array. \n```javascript\nvar myGroceryStore = new Store();\n\nmyGroceryStore.add('fruit', 'apples', 'oranges');\n```\nNow that we have an array, we can call `forEach` on it, and with our value index, and array arguments, we're going to go ahead and push all of these new fruits to the fruits category.\n```javascript\nreturn {\n   //Store().add('category', 'item1', 'item2');\n    add: function(category) {\n      var items = [].splice.call(arguments, 1);\n      console.log(items);\n      items.forEach(function(value, index, array) {\n        aisle[category].push(value);\n      });\n    },\n}\n```\nAfter calling add on our new grocery store, we can access the aisle, and see that the fruit `aisle` has `apples` and `oranges` added to it. \n```javascript\nmyGroceryStore.add('fruit', 'apples', 'oranges');\nconsole.log(myGroceryStore.aisle;)\n  // [object Object] {\n  //  fruit: [\"apples\", \"oranges\"],\n  //  vegetable: []  \n  //}\n```\nNow let's simplify this with the new **rest parameters** of ES6. The way that we access this is by doing **three dots**, followed by the variable we want to represent the array of the remaining arguments.\n\nBecause this is already an array, we don't have to transform our array like arguments into an actual array, so we can just console out items, run this again, and see that we get an array of `apples` and `oranges` immediately. We can also see that our fruit `aisle` has the `apples` and `oranges` items inside of the array.\n```javascript\nreturn {\n   //Store().add('category', 'item1', 'item2');\n    add: function(category, ...items) {\n   //   var items = [].splice.call(arguments, 1);\n      console.log(items); // [\"apples\", \"oranges\"]\n      items.forEach(function(value, index, array) {\n        aisle[category].push(value);\n      });\n    },\n}\n```\nAll arguments declared before the rest parameters will be represented by those variables, however, any remaining arguments will be inserted into the new rest array. Because of this, we don't have to remove category from our array, as it is already not included."},{"lesson_slug":"the-let-keyword","enhanced_transcript":"A long-standing gotcha with JavaScript is how **var** works. If I have this `message` assigned to `hi`, and I have this `message` assigned to `bye`, you'd probably think, \"This one's inside of a **block** so it should have no impact on what this `message` does up here.\" But if I run this, you'll actually see that that isn't the case. `Bye` is being logged out because this is the same `message`, and it's being **reassigned** to `bye`.\n``` javascript\nvar message = \"hi\";\n{\n  var message = \"bye\";\n}\n\nconsole.log(message); // bye\n```\n**ES5** does have **function scoping**, so if I were to create a `function` and lock it inside of there, then it wouldn't have any impact, and I would get `hi`. But if I were to create a **for loop**, or some other thing that could use a block, then that wouldn't work, and I get the same result as logging out, `bye`, each time. \n``` javascript\nvar message = \"hi\";\n\nfunction greet(){\n  var message = \"bye\";\n}\n\nconsole.log(message); // hi\n```\nTo help with this problem, we do have **let** in **ES6**, which will allow me to use **block scoping**.\n``` javascript\nlet message = \"hi\";\n{\n  let message = \"bye\";\n}\n\nconsole.log(message); // hi\n```\nIf I rerun this, you'll see that we still get `hi`, even though we have `message` here, and `message` here. This `message`, because it's inside of a block, even though it's not inside of a function, has no impact on the assignment of this `message`. They are two **separate and different entities**. Let's explore this behavior in a bit more detail by creating an array of functions, and a loop where we say `var i` is assigned to `0`, `i < 10`, and `i` is incremented, so `i++`.\n``` javascript\nvar fs = [];\n  for(var i = 0; i < 10; i++) {\n    fs.push(function (){\n      console.log(i);\n    })\n  }\n```\nThen we will add a new function to our array each time we go through, which will store `i`, and log it out for us. If we loop through the array of functions using a `forEach`, which will pass in `f`, and then invoke `f()`. \n``` javascript\nfs.forEach(function (f) {\n  f();  // 10 10 10 10 10 10 10 10 10 10\n})\n```\nAgain, this function here, which is being passed in through our `forEach` is simply this `function` storing our `i`. You'd think that we'd get **zero through 9**, but in fact when we run this we'll get **10's**, because this `i` is that same `i` being used and reassigned each time.\n\nIf I use **let** instead of var now, and rerun this, you'll see that I get **zero through 9**, and it stops before getting to 10, because this is creating a new `i` each time you go through the for loop. \n``` javascript\nvar fs = [];\n  for(let i = 0; i < 10; i++) {\n    fs.push(function (){\n      console.log(i); // 0 1 2 3 4 5 6 7 8 9\n    })\n  }\n```\nWhat this really means in the end is that if you're used to bringing your variables up to the top of a scope using **var** and things like `var i`, `var temp`, where you want to be careful, because you're afraid of [hoisting](https://egghead.io/lessons/javascript-hoisting-in-javascript) behaviors due to this `i`, and this `temp`,\n``` javascript\n// ES5\nfunction varFunc(){\n  var previous = 0;\n  var current = 1;\n  var i;\n  var temp;\n  \n  for(i = 0; i < 10; i+=1){\n    temp = previous;\n    previous = current;\n    current = temp + current;\n  }\n}\n```\nfeel free now to use the let keyword, and instead of declaring it at the top, you can declare it **in-line**, inside of the **for statement**, as well as declaring it inside of the **for block**, and it'll safely create this `temp` **each time** it goes through the for block.\n``` javascript\n// ES6\nfunction letFunc(){\n  let previous = 0;\n  let current = 1;\n  \n  for(let i = 0; i < 10; i+=1){\n    let temp = previous;\n    previous = current;\n    current = temp + current;\n  }\n}\n```"}]
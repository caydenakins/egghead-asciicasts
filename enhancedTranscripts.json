{"lessonSlug":"javascript-redux-writing-a-todo-list-reducer-toggling-a-todo","asciicast":"In this lesson, we will continue creating the **reducer** for to-do list application. The only action that this reducer currently handles is called `Add_TODO`. We also created a test that makes sure that when the `reducer` is called with an empty array as a state and the `Add_TODO` action, it returns an array with a single to do element.\n\nIn this lesson, we will follow the same approach to implement another action called `Toggle_ToDo`. We're going to start with a test again. This time, we're testing a different action and we have a different initial state. The state before calling the `reducer` now includes two different to-dos with ID zero and one. Notice how both of them have their completed fields set to `false`.\n\n``` javascript\nconst testToggleTodo = () => {\n  const stateBefore = [\n    {\n      id: 0,\n      text: 'Learn Redux',\n      completed: false\n    },\n    {\n      id: 1,\n      text: 'Go shopping',\n      completed: false\n    }\n  ];\n};\n```\n\nNext, I declare the `action`. The `action` is an object with the type property which is a toggle to-do string and the ID of the to-do that I want to be toggled. I declare the state that I expect to receive after calling the `reducer`. It's pretty much the same as before calling the `reducer`. However, I expect the to-do with the ID specified in the action or one in this case. The change is completed field.\n\n``` javascript\nconst action = {\n  type: 'TOGGLE_TODO',\n  id: 1\n};\nconst stateAfter = [\n  {\n    id: 0,\n    text: 'Learn Redux',\n    completed: false\n  },\n  {\n    id: 1,\n    text: 'Go shopping',\n    completed: true\n  }\n];\n```\n\nThe reducer must be a **pure function**. As a matter of precaution, I called `deepFreeze` on the state and the action. Finally, just like in the previous lesson, I'm asserting that the result of calling my `reducer` with the state before and the action is going to be **deeply equal** to the state after.\n\n``` javascript\ndeepFreeze(stateBefore);\ndeepFreeze(action);\n\nexpect(\n  todos(stateBefore, action)\n).toEqual(stateAfter);\n```\n\nMy test is a function, so I need to call it at the end of the file. If I run it, it fails because I have not implemented handling this action yet.\n\nI'm adding a new switch case to my **reducer**. I remember that I shouldn't change the original array, so I'm using the **array map** method to produce a new array.\n\nThe function I pass as an argument will be called for every to-do. If it's not a to-do I'm looking for, I don't want to change it. I just return it as is. However, if the to-do is the one we want to toggle, I'm going to return a new object that has all the properties of the original to-do object thanks to the object's **spread operator**, but also an inverted value of the completed field.\n\n\n``` javascript\ncase 'TOGGLE_TODO':\n      return state.map(todo => {\n        if (todo.id !== action.id) {\n          return todo;\n        }\n\n        return {\n          ...todo,\n          completed: !todo.completed\n        };\n```\n\nNow both of our tests run successfully. We have an implementation of the **reducer** that can add and toggle to-dos.\n"}